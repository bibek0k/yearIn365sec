<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memory Archive</title>
    <link rel="shortcut icon" href="assets/LogoIcon.svg" type="image/x-icon">
    
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --primary: #e11d48; /* Rose-600 */
            --bg: #0f172a; /* Slate-900 */
            --surface: #1e293b; /* Slate-800 */
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            overscroll-behavior-y: none;
        }

        /* Subtle Fade In Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .camera-container {
            position: relative;
            width: 100%;
            padding-top: 133.33%; /* 3:4 Aspect Ratio (480x640) */
            background: #000;
            border-radius: 2rem; /* Softer corners */
            overflow: hidden;
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.6);
            transition: box-shadow 0.1s ease-in-out;
        }

        /* Screen Flash: Warm White Shadow covering everything OUTSIDE the camera container */
        .camera-container.flash-active {
            box-shadow: 0 0 0 200vmax rgba(255, 248, 235, 0.95); /* Warm White */
            z-index: 100;
        }

        .camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
        }

        /* CSS Mirroring for Preview */
        .camera-feed.mirrored {
            transform: scaleX(-1);
        }
        
        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }
        
        /* Responsive Grid for Tablet/Desktop */
        @media (min-width: 768px) {
            .calendar-grid {
                gap: 0.75rem;
            }
        }

        .day-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border-radius: 1.25rem; /* Softer */
            font-size: 0.7rem;
            color: var(--text-muted);
            /* UPDATED: Added opacity transition for smooth re-entry */
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.2s ease, opacity 0.3s ease;
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
            z-index: 1;
        }

        .day-cell:hover {
            border-color: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .day-cell.filled {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(225, 29, 72, 0.3);
        }
        
        .day-cell.target-active {
            border-color: #3b82f6; /* Blue border for target */
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
        }
        
        /* When animating, hide the original cell to avoid duplication visual */
        .day-cell.animating-source {
            opacity: 0 !important;
            visibility: hidden;
        }

        .safe-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Premium Toggle Switch */
        .mode-toggle {
            background: rgba(30, 41, 59, 0.6); /* Glassy surface */
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 9999px;
            padding: 4px;
            display: flex;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .mode-btn {
            z-index: 10;
            flex: 1;
            text-align: center;
            padding: 8px 16px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 9999px;
            transition: color 0.3s ease;
            cursor: pointer;
            letter-spacing: 0.02em;
        }
        .mode-bg {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc(50% - 4px);
            background: var(--primary);
            border-radius: 9999px;
            box-shadow: 0 2px 8px rgba(225, 29, 72, 0.4);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Shake Animation for Invalid Input */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-4px); }
            80% { transform: translateX(4px); }
        }
        .animate-shake {
            animation: shake 0.4s ease-in-out;
        }
        
        /* Custom scrollbar for lists */
        .scrollbar-thin::-webkit-scrollbar { width: 4px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }

        /* Loader Animation */
        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 3px solid #fff;
            width: 20px;
            height: 20px;
            -webkit-animation: spin 1s linear infinite; /* Safari */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* UPDATED: iOS-Style Morphing Transitions 
           The modal container handles the backdrop fade.
           The inner div handles the transform/geometry morph.
        */
        #clipModal {
            transition: backdrop-filter 0.5s ease, background-color 0.5s ease;
            will-change: backdrop-filter, background-color;
        }
        
        #clipModal.modal-hidden {
            backdrop-filter: blur(0px);
            background-color: transparent;
            pointer-events: none;
        }

        #clipModal > div {
            /* We use a custom cubic-bezier that mimics iOS app open physics:
               Starts fast, then has a long, smooth deceleration.
            */
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        opacity 0.5s cubic-bezier(0.2, 0.8, 0.2, 1),
                        border-radius 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-origin: top left; /* Crucial for the coordinate mapping */
            will-change: transform, opacity, border-radius;
        }

        /* Fallback for simple fade if no source element */
        .simple-fade-enter {
            animation: simpleFadeIn 0.3s ease-out forwards;
        }
        @keyframes simpleFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center safe-pb bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-slate-950">

    <!-- Header & Mode Switch -->
    <header class="w-full max-w-5xl px-6 py-8 flex flex-col gap-8 z-10 animate-fade-in">
        <div class="flex flex-col md:flex-row justify-between items-start md:items-end gap-6">
            <!-- Greeting Block -->
            <div class="flex flex-col gap-2">
                <h1 id="greetingLine1" class="text-3xl md:text-4xl font-bold text-white tracking-tight leading-tight drop-shadow-sm">Hi,</h1>
                <p id="greetingLine2" class="text-sm md:text-base font-medium text-slate-400 tracking-wide flex items-center gap-2">Loading...</p>
            </div>
            
            <!-- Mode Toggle -->
            <div class="mode-toggle w-48 flex-shrink-0 self-start md:self-auto">
                <div id="modeBg" class="mode-bg"></div>
                <div id="modeSelf" class="mode-btn text-white">Self</div>
                <div id="modeScene" class="mode-btn text-slate-400">Scene</div>
            </div>
        </div>
        
        <!-- Search Bar Wrapper -->
        <div class="w-full relative group">
            <div id="searchContainer" class="flex items-center gap-3 w-full transition-all duration-300 bg-slate-800/50 hover:bg-slate-800/70 border border-slate-700/50 hover:border-slate-600 focus-within:border-rose-500/50 focus-within:bg-slate-800 focus-within:ring-4 focus-within:ring-rose-500/10 rounded-2xl px-2 py-2 backdrop-blur-sm">
                
                <input type="text" id="dateSearchInput" placeholder="Jump to memory (DD-MM-YYYY or Day-X)" 
                    class="bg-transparent text-slate-200 px-3 py-2 flex-1 text-sm font-medium focus:outline-none placeholder-slate-500 transition-colors">
                
                <button id="btnSearch" class="bg-slate-700/50 hover:bg-rose-600 text-slate-300 hover:text-white p-2.5 rounded-xl transition-all duration-200">
                    <i data-lucide="search" class="w-4 h-4"></i>
                </button>
            </div>
            <!-- Error Label -->
            <div id="searchError" class="absolute -bottom-6 left-2 flex items-center gap-1.5 opacity-0 pointer-events-none transition-all duration-200 transform translate-y-[-4px]">
                <i data-lucide="alert-circle" class="w-3 h-3 text-rose-500"></i>
                <span class="text-rose-500 text-xs font-semibold tracking-wide">Error message</span>
            </div>
        </div>

        <!-- Recording Target Indicator (Subtle) -->
        <div id="targetIndicator" class="hidden w-full bg-blue-500/5 border border-blue-500/10 rounded-xl p-3 text-center backdrop-blur-md">
            <p class="text-blue-400/90 text-xs font-semibold tracking-wide">Recording for <span id="targetDateDisplay" class="text-blue-300"></span></p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="w-full max-w-5xl flex-1 px-4 flex flex-col md:flex-row gap-8 items-start justify-center">

        <!-- Recorder Section Wrapper -->
        <div class="w-full md:w-[26rem] lg:w-[28rem] flex-shrink-0 mx-auto md:mx-0 md:sticky md:top-6">
            <div id="recorderSection" class="relative">
                <div id="cameraContainer" class="camera-container">
                    <video id="cameraPreview" autoplay playsinline muted class="camera-feed hidden"></video>
                    <video id="playbackPreview" playsinline loop class="camera-feed hidden"></video>
                    
                    <!-- Start Overlay -->
                    <div id="startOverlay" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-950/40 backdrop-blur-sm z-10 transition-opacity">
                        <button id="btnInitCamera" class="bg-rose-600 hover:bg-rose-700 text-white rounded-full p-6 shadow-xl shadow-rose-900/20 transform transition-all duration-300 hover:scale-105 active:scale-95">
                            <i data-lucide="camera" class="w-8 h-8"></i>
                        </button>
                        <p class="mt-5 text-sm font-semibold text-white/90 tracking-wide">Tap to Capture</p>
                    </div>

                    <!-- Done Overlay -->
                    <div id="doneOverlay" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-slate-950/80 backdrop-blur-md z-20">
                        <div class="bg-emerald-500/20 text-emerald-400 p-4 rounded-full mb-4 ring-1 ring-emerald-500/30">
                            <i data-lucide="check" class="w-8 h-8"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-white tracking-tight">Memory Saved</h3>
                        <div class="flex gap-4 mt-8">
                             <button id="btnViewClip" class="text-sm font-semibold bg-slate-800 hover:bg-slate-700 text-white px-6 py-2.5 rounded-full transition-colors border border-slate-700">Review</button>
                        </div>
                    </div>

                    <!-- Camera Tools (Switch & Flash) -->
                    <div class="absolute top-5 right-5 z-30 flex flex-col gap-3">
                        <button id="btnSwitchCam" class="hidden bg-black/40 hover:bg-black/60 text-white p-2.5 rounded-full backdrop-blur-md transition-all border border-white/10">
                            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                        </button>
                        <button id="btnFlash" class="hidden bg-black/40 hover:bg-black/60 text-slate-300 p-2.5 rounded-full backdrop-blur-md transition-all border border-white/10">
                            <i id="iconFlash" data-lucide="zap-off" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>

                <!-- Controls -->
                <div class="mt-8 flex items-center justify-center relative h-24">
                    <div id="recordControls" class="relative hidden">
                        <svg class="progress-ring w-24 h-24" viewBox="0 0 100 100">
                            <circle class="text-slate-800" stroke="currentColor" stroke-width="3" fill="transparent" r="45" cx="50" cy="50"/>
                            <circle id="progressCircle" class="progress-ring__circle text-rose-500 drop-shadow-[0_0_8px_rgba(225,29,72,0.6)]" stroke="currentColor" stroke-width="3" fill="transparent" r="45" cx="50" cy="50" stroke-dasharray="282.74" stroke-dashoffset="282.74"/>
                        </svg>
                        
                        <button id="btnRecord" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-20 h-20 bg-rose-600 rounded-full border-[6px] border-slate-950 shadow-2xl active:scale-90 transition-transform flex items-center justify-center group">
                            <div id="recIcon" class="w-8 h-8 bg-white rounded-sm group-hover:scale-90 transition-transform duration-200"></div>
                        </button>
                    </div>
                    <p id="statusText" class="absolute -bottom-4 text-[10px] uppercase tracking-widest text-slate-500 font-bold opacity-0 transition-opacity duration-300">Ready</p>
                </div>
            </div>
        </div>

        <!-- Hidden Canvas for recording processing -->
        <canvas id="processingCanvas" class="hidden"></canvas>

        <!-- Month Grid View -->
        <div class="w-full md:flex-1 bg-slate-800/40 border border-slate-700/30 rounded-2xl p-6 flex flex-col gap-6 backdrop-blur-sm">
            <!-- Month Navigation -->
            <div class="flex justify-between items-center px-1">
                <button id="btnPrevMonth" class="p-2 hover:bg-slate-700/50 rounded-full text-slate-400 hover:text-white transition-colors"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                <h2 id="monthLabel" class="text-sm font-bold text-slate-200 uppercase tracking-widest">Month</h2>
                <button id="btnNextMonth" class="p-2 hover:bg-slate-700/50 rounded-full text-slate-400 hover:text-white transition-colors"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
            </div>

            <!-- Grid -->
            <div id="calendarGrid" class="calendar-grid">
                <!-- Days injected by JS -->
            </div>

            <!-- Tools -->
            <div class="flex gap-3 justify-center border-t border-slate-700/50 pt-6 flex-wrap">
                <!-- Music Input for Month View (Wrapper with Remove Logic) -->
                <div id="monthMusicWrapper" class="flex items-center bg-slate-800 rounded-lg border border-slate-700 transition-all hover:border-slate-600 group/music max-w-[280px]">
                    <label id="lblMonthMusic" class="cursor-pointer flex items-center gap-2 px-3 py-2.5 text-xs font-semibold text-slate-400 hover:text-white transition-colors flex-1 min-w-0" title="Replace Music">
                        <input type="file" id="monthMusicInput" accept="audio/*" class="hidden">
                        <i id="monthMusicIcon" data-lucide="music" class="w-3.5 h-3.5 flex-shrink-0 group-hover/music:text-rose-400 transition-colors"></i> 
                        <span id="monthMusicText" class="truncate">Add Music</span>
                    </label>
                    <!-- Divider -->
                    <div id="musicDivider" class="hidden w-px h-4 bg-slate-700"></div>
                    <!-- Trim Button -->
            <button id="btnTrimMusic" class="hidden px-2.5 py-2.5 text-slate-500 hover:text-blue-400 hover:bg-slate-700/50 transition-colors" title="Trim Music">
                <i data-lucide="sliders-horizontal" class="w-3.5 h-3.5"></i>
            </button>
            <!-- Remove Button -->
                    <button id="btnRemoveMonthMusic" class="hidden px-2.5 py-2.5 text-slate-500 hover:text-rose-400 hover:bg-slate-700/50 transition-colors border-l border-slate-700/50 rounded-r-lg" title="Remove Music">
                        <i data-lucide="x" class="w-3.5 h-3.5"></i>
                    </button>
                </div>

                <button id="btnCompile" class="text-xs font-semibold bg-slate-800 hover:bg-slate-700 text-slate-200 px-5 py-2.5 rounded-lg flex items-center gap-2 transition-all border border-slate-700 hover:border-slate-600">
                    <i data-lucide="film" class="w-3.5 h-3.5"></i> Compile Month
                </button>
                <button id="btnImportCompile" class="text-xs font-semibold bg-slate-800 hover:bg-slate-700 text-slate-200 px-5 py-2.5 rounded-lg flex items-center gap-2 transition-all border border-slate-700 hover:border-slate-600">
                    <i data-lucide="upload" class="w-3.5 h-3.5"></i> Import & Compile
                </button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="w-full text-center py-8 text-slate-600 text-[10px] font-semibold uppercase tracking-widest opacity-60">
        <p>Memory Archive â€¢ Created by Bibek</p>
    </footer>

    <!-- Clip Viewer / Delete Modal -->
    <div id="clipModal" class="fixed inset-0 bg-slate-950/95 z-40 hidden flex-col items-center justify-center p-4 sm:p-6 modal-hidden">
        <div class="relative w-full max-w-md md:max-w-lg max-h-[90vh] overflow-y-auto bg-slate-900 rounded-2xl overflow-hidden shadow-2xl border border-slate-800 flex flex-col transform-gpu">
            <div class="absolute top-4 left-0 w-full flex flex-col items-center gap-2 z-10 pointer-events-none">
                <span id="modalDateDisplay" class="bg-black/60 backdrop-blur-md text-white/90 px-5 py-1.5 rounded-full text-xs font-bold tracking-wide shadow-lg border border-white/5 uppercase"></span>
                <span id="modalTimeDisplay" class="hidden bg-black/60 backdrop-blur-md text-slate-300 px-3 py-1 rounded-full text-[10px] font-medium tracking-wide shadow-lg border border-white/5"></span>
            </div>
            <video id="modalVideo" controls playsinline webkit-playsinline class="w-full aspect-[3/4] bg-black block"></video>
            <div class="p-5 flex justify-between items-center bg-slate-900 sticky bottom-0 z-20 border-t border-slate-800">
                <button id="btnCloseClip" class="text-slate-400 hover:text-white text-xs font-semibold uppercase tracking-wider transition-colors px-2">Close</button>
                <div class="flex gap-3">
                    <button id="btnDownloadClip" class="bg-slate-800 hover:bg-slate-700 text-slate-200 p-2.5 rounded-full transition-colors border border-slate-700 flex items-center justify-center">
                        <span id="dlIconContainer" class="flex items-center justify-center"><i data-lucide="download" class="w-4 h-4"></i></span>
                        <div id="dlSpinner" class="hidden spinner w-4 h-4"></div>
                    </button>
                    <button id="btnReplaceClip" class="bg-slate-800 hover:bg-slate-700 text-blue-400 p-2.5 rounded-full transition-colors border border-slate-700">
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                    </button>
                    <button id="btnDeleteClip" class="bg-slate-800 hover:bg-red-900/30 text-red-400 p-2.5 rounded-full transition-colors border border-slate-700 group">
                        <i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Compile Modal (Internal Clips) -->
    <div id="compileModal" class="fixed inset-0 bg-slate-950/80 backdrop-blur-sm z-50 hidden flex-col items-center justify-center p-6 transition-opacity duration-300">
        <div class="relative w-full max-w-sm bg-slate-900 border border-slate-800 rounded-2xl p-8 shadow-2xl flex flex-col items-center">
            
            <!-- Top Right Close (Cancel/Exit) - Smaller, secondary -->
            <button id="btnCancelCompile" class="absolute top-4 right-4 p-2 text-slate-600 hover:text-slate-400 transition-colors">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>

            <!-- Title - Dominant, larger, semi-bold, centered -->
            <h3 class="text-lg font-semibold text-slate-200 mb-10 tracking-tight">Compiling Month</h3>
            
            <!-- Preview Video/Card - Less noise, padding, rounded corners -->
            <div class="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-8 shadow-md ring-1 ring-slate-800">
                <canvas id="compileCanvas" class="w-full h-full object-contain"></canvas>
                
                <!-- Status Badge - Smaller, less saturated, status label -->
                <div id="compileBadge" class="absolute top-3 left-3 bg-slate-900/90 backdrop-blur-sm border border-slate-700/50 px-2 py-1 rounded text-[10px] font-medium text-slate-400 uppercase tracking-wide flex items-center gap-2 transition-colors duration-300">
                    <div class="w-1.5 h-1.5 bg-current rounded-full animate-pulse opacity-60"></div>
                    <span id="compileBadgeText">Processing</span>
                </div>
            </div>

            <!-- Progress Section - Muted, secondary, slimmer bar -->
            <div class="w-full flex flex-col gap-3 mb-8">
                <div class="flex justify-between items-end px-1">
                    <span id="compileLog" class="text-[10px] font-medium text-slate-500 uppercase tracking-wider">Initializing...</span>
                    <span id="compilePercent" class="text-[10px] font-mono text-slate-600">0%</span>
                </div>
                <!-- Slimmer bar -->
                <div class="w-full bg-slate-800 h-1 rounded-full overflow-hidden">
                    <div id="compileProgress" class="bg-slate-500 h-full w-0 transition-all duration-300 rounded-full"></div>
                </div>
            </div>

            <!-- Save & Close Button - Calm, neutral, rounded -->
            <button id="btnCloseModal" class="hidden w-full bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white py-3 rounded-xl transition-all font-medium text-sm border border-slate-700/50">
                Save & Close
            </button>
        </div>
    </div>

    <!-- NEW: Import & Compile Modal -->
    <div id="importCompileModal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-md z-50 hidden flex-col items-center justify-center p-4 sm:p-6 overflow-y-auto">
        <div class="relative w-full max-w-2xl bg-slate-900 border border-slate-800 p-8 rounded-3xl shadow-2xl flex flex-col gap-6 max-h-[90vh]">
            <h3 id="importModalTitle" class="text-xl font-bold text-center text-white">Import Memories</h3>
            
            <!-- Import Content Area -->
            <div id="importContentArea" class="flex flex-col gap-6 w-full">
                <!-- Drop Zone -->
                <label id="dropZone" class="border-2 border-dashed border-slate-700 hover:border-rose-500/50 hover:bg-rose-500/5 bg-slate-800/30 rounded-2xl p-10 text-center transition-all cursor-pointer flex flex-col items-center gap-3 group">
                    <input type="file" id="fileInput" multiple accept="video/*" class="hidden">
                    <div class="p-4 bg-slate-800 rounded-full group-hover:scale-110 transition-transform duration-300">
                        <i data-lucide="upload-cloud" class="w-8 h-8 text-rose-500"></i>
                    </div>
                    <strong class="text-slate-200 mt-2">Click or Drag Videos Here</strong>
                    <p class="text-xs text-slate-500">Supports: username_self_DD-MM-YYYY.* or scene_DD-MM-YYYY.*</p>
                </label>

                <!-- Music Input for Import Modal -->
                <label class="cursor-pointer bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-xl p-4 flex items-center justify-between transition-all group">
                     <div class="flex items-center gap-3">
                        <div class="bg-slate-700 text-slate-400 group-hover:text-rose-400 p-2 rounded-lg transition-colors">
                            <i data-lucide="music" class="w-5 h-5"></i>
                        </div>
                        <div class="flex flex-col text-left">
                            <span class="text-sm font-semibold text-slate-200">Background Music (Optional)</span>
                            <span id="importMusicText" class="text-xs text-slate-500">Tap to select audio file</span>
                        </div>
                     </div>
                     <input type="file" id="importMusicInput" accept="audio/*" class="hidden">
                     <i id="importMusicCheck" data-lucide="plus" class="w-4 h-4 text-slate-500"></i>
                </label>

                <!-- File Lists Container - Dynamic Per User -->
                <div id="importListContainer" class="flex flex-col gap-6 w-full max-h-[40vh] overflow-y-auto scrollbar-thin pr-1">
                    <p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>
                </div>
            </div>

            <!-- Processing Area (Hidden by default) -->
            <div id="importProgressArea" class="hidden w-full flex flex-col gap-6">
                 <!-- Preview Canvas -->
                 <div class="relative w-full aspect-video bg-black rounded-xl overflow-hidden shadow-lg border border-slate-800 mx-auto max-w-md">
                     <canvas id="importPreviewCanvas" class="w-full h-full object-contain"></canvas>
                     <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent flex flex-col justify-end p-4">
                        <span id="importStatusLog" class="text-xs font-mono text-emerald-400 truncate">Initializing...</span>
                     </div>
                 </div>

                 <!-- Progress Bar -->
                 <div class="w-full flex flex-col gap-2">
                     <div class="flex justify-between text-xs font-semibold text-slate-400 uppercase tracking-wider">
                         <span>Total Progress</span>
                         <span id="importPercentDisplay">0%</span>
                     </div>
                     <div class="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                         <div id="importProgressBar" class="bg-rose-500 h-full w-0 transition-all duration-300 rounded-full"></div>
                     </div>
                 </div>
            </div>

            <!-- Download Links (Hidden by default) -->
            <div id="importDownloadLinks" class="hidden w-full flex flex-col gap-3 max-h-[30vh] overflow-y-auto scrollbar-thin">
                <!-- Dynamic Links -->
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-4 pt-4 border-t border-slate-800 w-full mt-auto">
                <button id="btnCloseImportModal" class="px-6 py-3 text-slate-400 hover:text-white font-semibold transition-colors">Close</button>
                <button id="btnStartImportCompile" disabled class="flex-1 bg-rose-600 hover:bg-rose-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-all shadow-lg shadow-rose-900/20 flex items-center justify-center gap-2">
                    <i data-lucide="film" class="w-4 h-4"></i>
                    Start Compilation
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Music Trim Modal -->
    <div id="trimModal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-sm z-50 hidden flex-col items-center justify-center p-4">
        <div class="w-full max-w-md bg-slate-900 border border-slate-800 rounded-2xl p-6 shadow-2xl flex flex-col gap-6">
            <div class="flex justify-between items-center">
                <h3 class="text-lg font-bold text-slate-200">Select Music Segment</h3>
                <span id="trimTotalTime" class="text-xs font-mono text-emerald-400 bg-emerald-900/20 px-2 py-1 rounded border border-emerald-900/50">Video Length: 0s</span>
            </div>
            
            <div class="w-full bg-slate-950 rounded-xl p-4 border border-slate-800 flex flex-col gap-4">
                <!-- Visual Timeline Container -->
                <div id="trimTrackContainer" class="relative w-full h-16 bg-slate-800/50 rounded-lg overflow-hidden cursor-pointer touch-none select-none group">
                    <!-- Fake Waveform Background -->
                    <div class="absolute inset-0 opacity-30" 
                         style="background-image: linear-gradient(90deg, #94a3b8 2px, transparent 2px); background-size: 5px 100%;">
                    </div>
                    
                    <!-- Progress / Playhead Indicator (Optional visual aid) -->
                    <div id="trimPlayhead" class="absolute top-0 bottom-0 w-px bg-white/50 z-0 hidden"></div>

                    <!-- The Draggable Window -->
                    <div id="trimWindow" class="absolute top-0 h-full border-2 border-rose-500 bg-rose-500/20 z-10 rounded-md cursor-grab active:cursor-grabbing flex items-center justify-center overflow-hidden">
                        <!-- NEW: Progress Bar inside window -->
                        <div id="trimProgressBar" class="absolute top-0 left-0 h-full bg-white/30 pointer-events-none w-0 transition-[width] duration-75 ease-linear"></div>
                        
                        <!-- Handle Visuals -->
                        <div class="relative w-1 h-6 bg-rose-500/50 rounded-full mx-auto pointer-events-none z-20"></div>
                    </div>
                </div>

                <div class="flex justify-between text-[10px] text-slate-500 font-mono">
                    <span id="trimStartDisplay">0.0s</span>
                    <span id="trimEndDisplay">0.0s</span>
                </div>

                <audio id="trimAudioPreview" class="hidden"></audio>
            </div>

            <p class="text-[10px] text-slate-500 text-center italic">
                Drag the highlighted window to choose the part of the song that fits your <span id="trimClipCount">0</span> clips.
            </p>

            <div class="flex gap-3 pt-4 border-t border-slate-800">
                <button id="btnCancelTrim" class="flex-1 text-slate-400 hover:text-white text-sm font-semibold transition-colors">Cancel</button>
                <div class="flex-1 flex gap-2">
                    <button id="btnPreviewTrimSegment" class="px-4 bg-slate-800 hover:bg-slate-700 text-blue-400 rounded-xl transition-colors border border-slate-700 flex items-center justify-center">
                        <i id="iconPreviewTrim" data-lucide="play" class="w-4 h-4"></i>
                    </button>
                    <button id="btnSaveTrim" class="flex-1 bg-rose-600 hover:bg-rose-700 text-white font-bold py-2.5 rounded-xl transition-all shadow-lg shadow-rose-900/20">
                        Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- STATE & CONFIG ---
        const APP = {
            dbName: 'OneSecondADayDB',
            storeName: 'clips',
            version: 1,
            db: null,
            today: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            mediaRecorder: null,
            recordedChunks: [],
            cameraStream: null,
            
            // New State for V2
            mode: 'self', // 'self' or 'scene'
            viewDate: new Date(), // Tracks month view
            targetDate: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            sceneCamFacing: 'environment', // default rear for scene
            
            // Rendering loop
            animationId: null,

            // Flash State
            flashEnabled: false,
            hasTorch: false,
            trackRef: null,
            
            // Import Compiler State
            importState: {
                files: [], // Flat list of all imported files
                isProcessing: false
            },
            
            // Recording State (Audio Logic)
            recAudioCtx: null,
            
            // Music State
            musicConfig: {
                file: null,
                start: 0,
                end: null, // null means end of file
                duration: 0
            },
            
            // Trim State
            trimState: {
                isDragging: false,
                startX: 0,
                currentLeft: 0,
                containerWidth: 0,
                windowWidth: 0,
                videoDuration: 0,
                songDuration: 0,
                isPlaying: false, 
                previewTimeout: null,
                progressFrameId: null // New: For progress animation
            },

            // User Data
            userName: localStorage.getItem('user_name') || null,

            // Assets
            logoImg: null
        };
        
        // --- ANIMATION STATE ---
        let activeTriggerEl = null;

        // --- NEW: TIMEOUT HELPER ---
        const withTimeout = (promise, ms, errorMsg) => Promise.race([
            promise,
            new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg)), ms))
        ]);

        const DOM = {
            // Displays
            greetingLine1: document.getElementById('greetingLine1'),
            greetingLine2: document.getElementById('greetingLine2'),
            targetDateDisplay: document.getElementById('targetDateDisplay'),
            targetIndicator: document.getElementById('targetIndicator'),
            monthLabel: document.getElementById('monthLabel'),
            statusText: document.getElementById('statusText'),
            
            // Search
            dateSearchInput: document.getElementById('dateSearchInput'),
            btnSearch: document.getElementById('btnSearch'),
            searchContainer: document.getElementById('searchContainer'),
            searchError: document.getElementById('searchError'),

            // Camera
            cameraContainer: document.getElementById('cameraContainer'),
            cameraPreview: document.getElementById('cameraPreview'),
            playbackPreview: document.getElementById('playbackPreview'),
            processingCanvas: document.getElementById('processingCanvas'), 
            
            // Mode Switcher
            modeSelf: document.getElementById('modeSelf'),
            modeScene: document.getElementById('modeScene'),
            modeBg: document.getElementById('modeBg'),
            
            // Overlays & Buttons
            startOverlay: document.getElementById('startOverlay'),
            doneOverlay: document.getElementById('doneOverlay'),
            btnInit: document.getElementById('btnInitCamera'),
            btnRecord: document.getElementById('btnRecord'),
            btnSwitchCam: document.getElementById('btnSwitchCam'),
            btnViewClip: document.getElementById('btnViewClip'),
            btnFlash: document.getElementById('btnFlash'),
            iconFlash: document.getElementById('iconFlash'),

            // Grid & Nav
            calendarGrid: document.getElementById('calendarGrid'),
            btnPrevMonth: document.getElementById('btnPrevMonth'),
            btnNextMonth: document.getElementById('btnNextMonth'),
            
            // Modals
            clipModal: document.getElementById('clipModal'),
            modalVideo: document.getElementById('modalVideo'),
            modalDateDisplay: document.getElementById('modalDateDisplay'),
            modalTimeDisplay: document.getElementById('modalTimeDisplay'),
            btnCloseClip: document.getElementById('btnCloseClip'),
            btnDeleteClip: document.getElementById('btnDeleteClip'),
            btnReplaceClip: document.getElementById('btnReplaceClip'),
            btnDownloadClip: document.getElementById('btnDownloadClip'),
            dlIconContainer: document.getElementById('dlIconContainer'),
            dlSpinner: document.getElementById('dlSpinner'),
            
            // Compile
            btnCompile: document.getElementById('btnCompile'),
            compileModal: document.getElementById('compileModal'),
            compileProgress: document.getElementById('compileProgress'),
            compileLog: document.getElementById('compileLog'),
            compilePercent: document.getElementById('compilePercent'),
            btnCloseModal: document.getElementById('btnCloseModal'),
            btnCancelCompile: document.getElementById('btnCancelCompile'),
            compileCanvas: document.getElementById('compileCanvas'),
            compileBadge: document.getElementById('compileBadge'),
            compileBadgeText: document.getElementById('compileBadgeText'),
            monthMusicInput: document.getElementById('monthMusicInput'),
            monthMusicText: document.getElementById('monthMusicText'),
            lblMonthMusic: document.getElementById('lblMonthMusic'),
            monthMusicWrapper: document.getElementById('monthMusicWrapper'),
            monthMusicIcon: document.getElementById('monthMusicIcon'),
            btnRemoveMonthMusic: document.getElementById('btnRemoveMonthMusic'),
            btnTrimMusic: document.getElementById('btnTrimMusic'),
            musicDivider: document.getElementById('musicDivider'),
            
            // Trim Modal
            trimModal: document.getElementById('trimModal'),
            trimAudioPreview: document.getElementById('trimAudioPreview'),
            trimTrackContainer: document.getElementById('trimTrackContainer'),
            trimWindow: document.getElementById('trimWindow'),
            trimProgressBar: document.getElementById('trimProgressBar'), // New Ref
            trimStartDisplay: document.getElementById('trimStartDisplay'),
            trimEndDisplay: document.getElementById('trimEndDisplay'),
            trimTotalTime: document.getElementById('trimTotalTime'),
            trimClipCount: document.getElementById('trimClipCount'),
            
            btnPreviewTrimSegment: document.getElementById('btnPreviewTrimSegment'),
            iconPreviewTrim: document.getElementById('iconPreviewTrim'), // New Ref
            btnSaveTrim: document.getElementById('btnSaveTrim'),
            btnCancelTrim: document.getElementById('btnCancelTrim'),
            
            // Import Compiler
            btnImportCompile: document.getElementById('btnImportCompile'),
            importCompileModal: document.getElementById('importCompileModal'),
            importModalTitle: document.getElementById('importModalTitle'),
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            importContentArea: document.getElementById('importContentArea'),
            importListContainer: document.getElementById('importListContainer'),
            btnStartImportCompile: document.getElementById('btnStartImportCompile'),
            importProgressArea: document.getElementById('importProgressArea'),
            importPreviewCanvas: document.getElementById('importPreviewCanvas'),
            importProgressBar: document.getElementById('importProgressBar'),
            importStatusLog: document.getElementById('importStatusLog'),
            importPercentDisplay: document.getElementById('importPercentDisplay'),
            importDownloadLinks: document.getElementById('importDownloadLinks'),
            btnCloseImportModal: document.getElementById('btnCloseImportModal'),
            importMusicInput: document.getElementById('importMusicInput'),
            importMusicText: document.getElementById('importMusicText'),
            importMusicCheck: document.getElementById('importMusicCheck'),

            // Icons & Rings
            recordControls: document.getElementById('recordControls'),
            progressCircle: document.getElementById('progressCircle'),
            recIcon: document.getElementById('recIcon')
        };

        // --- INIT ---
        function getSafeUsername() {
            if (!APP.userName) return 'User';
            let name = APP.userName.replace(/\/BB$/, '');
            return name.replace(/[^a-zA-Z0-9-_]/g, '');
        }

        function formatDateDisplay(isoDateString) {
            if (!isoDateString) return '';
            
            if (isoDateString instanceof Date) {
                const y = isoDateString.getFullYear();
                const m = String(isoDateString.getMonth() + 1).padStart(2, '0');
                const d = String(isoDateString.getDate()).padStart(2, '0');
                return `${d}-${m}-${y}`;
            }

            if (typeof isoDateString !== 'string') return String(isoDateString);

            if (isoDateString.includes('-')) {
                const parts = isoDateString.split('-');
                if (parts.length === 3) {
                    const [y, m, d] = parts;
                    return `${d}-${m}-${y}`;
                }
            }
            return String(isoDateString);
        }

        function formatTimeDisplay(timestamp) {
            if (!timestamp) return '';
            return new Date(timestamp).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        }

        // --- GREETING LOGIC ---
        function updateGreeting() {
            const now = new Date();
            const hour = now.getHours();
            let timeGreeting = "Good morning";
            if (hour >= 12 && hour < 17) timeGreeting = "Good afternoon";
            else if (hour >= 17) timeGreeting = "Good evening";

            const dateOptions = { weekday: 'long', month: 'long', day: 'numeric' };
            const dateStr = now.toLocaleDateString('en-US', dateOptions);

            const name = APP.userName;
            let nameGreeting = "Hi,"; 

            if (name === "Barnita/BB") {
                const adjectives = ["gorgeous", "majestic", "lovely", "radiant", "elegant", "stunning"];
                const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
                nameGreeting = `Hi, ${randomAdj} Barnita,`;
            } else if (name === "Bibek/BB") {
                nameGreeting = "Hi Bibek boss,";
            } else {
                const cleanName = name ? name.replace(/\/BB$/, '') : '';
                nameGreeting = cleanName ? `Hi ${cleanName},` : "Hi,";
            }

            DOM.greetingLine1.textContent = nameGreeting;
            DOM.greetingLine2.innerHTML = `${timeGreeting} <span class="mx-2 text-slate-600 font-light text-lg align-middle">&bull;</span> ${dateStr}`;
        }

        // --- HAPTICS UTILITY ---
        const HAPTIC = {
            tap: 35,
            action: 75,
            success: 100,
            warning: 200,
            destructive: [100, 50, 150]
        };

        function vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }
        
        // --- DATABASE ---
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(APP.dbName, APP.version);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(APP.storeName)) {
                        db.createObjectStore(APP.storeName, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => { APP.db = e.target.result; resolve(APP.db); };
                request.onerror = (e) => reject(e);
            });
        }

        function getKey(date, mode) {
            return `${mode}_${date}`;
        }

        async function saveClip(date, mode, blob) {
            const id = getKey(date, mode);
            return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.put({ id: id, date: date, mode: mode, blob: blob, timestamp: Date.now() });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getClip(date, mode) {
            if (!APP.db) return null;
            const id = getKey(date, mode);
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        }
        
        async function deleteClip(date, mode) {
            const id = getKey(date, mode);
             return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getAllClips(mode) {
             if (!APP.db) return [];
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).getAll();
                req.onsuccess = () => {
                    const all = req.result || [];
                    resolve(all.filter(c => c.mode === mode));
                };
            });
        }

        // --- SEARCH LOGIC ---
        DOM.btnSearch.addEventListener('click', () => {
            vibrate(HAPTIC.tap); 
            handleSearch();
        });
        DOM.dateSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });

        DOM.dateSearchInput.addEventListener('input', () => {
             DOM.searchError.classList.add('opacity-0', 'pointer-events-none');
             DOM.searchError.classList.remove('translate-y-0');
             DOM.searchError.classList.add('translate-y-[-4px]');
             
             DOM.searchContainer.classList.remove('border-rose-500/50', 'ring-2', 'ring-rose-500/20');
             DOM.searchContainer.classList.add('border-slate-700/50');
        });

        function triggerSearchError(msg) {
            DOM.searchError.querySelector('span').textContent = msg;
            DOM.searchError.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-[-4px]');
            DOM.searchError.classList.add('translate-y-0');
            DOM.searchContainer.classList.remove('border-slate-700/50');
            DOM.searchContainer.classList.add('border-rose-500/50', 'ring-2', 'ring-rose-500/20');
            vibrate(HAPTIC.warning);
            DOM.searchContainer.classList.add('animate-shake');
            setTimeout(() => DOM.searchContainer.classList.remove('animate-shake'), 400);
        }

        async function handleSearch() {
            const input = DOM.dateSearchInput.value.trim();
            const dateRegex = /^(\d{2})-(\d{2})-(\d{4})$/;
            const dayRegex = /^Day-(\d+)$/i;

            let isoDate;
            let targetYear, targetMonth;

            if (dayRegex.test(input)) {
                const match = input.match(dayRegex);
                const dayNum = parseInt(match[1], 10);
                const currentYear = new Date().getFullYear();
                
                if (dayNum < 1 || dayNum > 366) {
                    triggerSearchError("Invalid Day Number");
                    return;
                }

                const calculatedDate = new Date(currentYear, 0, dayNum);
                if (calculatedDate.getFullYear() !== currentYear) {
                     triggerSearchError(`Day-${dayNum} does not exist in ${currentYear}`);
                     return;
                }

                const y = calculatedDate.getFullYear();
                const m = String(calculatedDate.getMonth() + 1).padStart(2, '0');
                const d = String(calculatedDate.getDate()).padStart(2, '0');
                isoDate = `${y}-${m}-${d}`;
                
                targetYear = y;
                targetMonth = calculatedDate.getMonth();

            } else if (dateRegex.test(input)) {
                const match = input.match(dateRegex);
                const [_, d, m, y] = match;
                isoDate = `${y}-${m}-${d}`;
                
                const testDate = new Date(isoDate);
                if (isNaN(testDate.getTime()) || testDate.getMonth() + 1 !== parseInt(m)) {
                    triggerSearchError("Date does not exist");
                    return;
                }
                
                targetYear = Number(y);
                targetMonth = Number(m) - 1;

            } else {
                triggerSearchError("Format: DD-MM-YYYY or Day-X");
                return;
            }

            const clip = await getClip(isoDate, APP.mode);
            if (clip && clip.blob && clip.blob.size > 0) {
                vibrate(HAPTIC.success);
                DOM.searchError.classList.add('opacity-0', 'pointer-events-none');
                DOM.searchContainer.classList.remove('border-rose-500/50', 'ring-2');
                DOM.searchContainer.classList.add('border-slate-700/50');
                APP.viewDate = new Date(targetYear, targetMonth, 1);
                updateMonthLabel();
                await renderCalendar();
                // Pass null trigger for search (fallback to fade)
                openClipModal(isoDate, null); 
            } else {
                triggerSearchError("No recording found.");
            }
        }

        // --- VIEW & NAVIGATION LOGIC ---

        function updateMonthLabel() {
            DOM.monthLabel.textContent = APP.viewDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        async function renderCalendar() {
            const clips = await getAllClips(APP.mode);
            const validClips = clips.filter(c => c.blob && c.blob.size > 0);
            const clipMap = new Map(validClips.map(c => [c.date, c]));
            
            DOM.calendarGrid.innerHTML = '';
            
            const year = APP.viewDate.getFullYear();
            const month = APP.viewDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                const dateObj = new Date(year, month, d);
                const dayOfYear = getDayOfYear(dateObj);
                
                const el = document.createElement('div');
                el.className = 'day-cell';
                el.title = formatDateDisplay(dateStr);
                
                const clip = clipMap.get(dateStr);
                const isTarget = dateStr === APP.targetDate;

                el.innerHTML = `<span class="text-[10px] font-bold opacity-60">Day</span><span class="text-lg font-bold leading-none mt-0.5">${dayOfYear}</span>`;

                if (clip) {
                    el.classList.add('filled');
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        openClipModal(clip, el); // Pass element for animation
                    };
                } else {
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        setTargetDate(dateStr);
                    };
                }

                if (isTarget) {
                    el.classList.add('target-active');
                }

                DOM.calendarGrid.appendChild(el);
            }
        }

        DOM.btnPrevMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() - 1);
            updateMonthLabel();
            renderCalendar();
        });

        DOM.btnNextMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() + 1);
            updateMonthLabel();
            renderCalendar();
        });

        // --- MODE SWITCHING ---

        function setMode(mode) {
            APP.mode = mode;
            APP.targetDate = APP.today;
            updateTargetUI();
            
            if (mode === 'self') {
                DOM.modeSelf.classList.replace('text-slate-400', 'text-white');
                DOM.modeScene.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(0)';
                DOM.btnSwitchCam.classList.add('hidden');
                DOM.cameraPreview.classList.add('mirrored');
            } else {
                DOM.modeScene.classList.replace('text-slate-400', 'text-white');
                DOM.modeSelf.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(100%)';
                DOM.cameraPreview.classList.remove('mirrored');
                if(APP.cameraStream) DOM.btnSwitchCam.classList.remove('hidden');
            }
            
            renderCalendar();
            resetRecorderUI();
            if (APP.cameraStream) startCamera(); 
        }

        DOM.modeSelf.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('self'); });
        DOM.modeScene.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('scene'); });

        // --- REPLACE / TARGET LOGIC ---

        function setTargetDate(date) {
            APP.targetDate = date;
            updateTargetUI();
            resetRecorderUI();
            renderCalendar();
        }
        
        function updateTargetUI() {
            DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
            if (APP.targetDate !== APP.today) {
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;
                DOM.statusText.classList.remove('opacity-0');
            } else {
                DOM.targetIndicator.classList.add('hidden');
                DOM.statusText.textContent = "Ready";
                DOM.statusText.classList.remove('opacity-0');
            }
            checkTargetStatus();
        }
        
        async function checkTargetStatus() {
            const existing = await getClip(APP.targetDate, APP.mode);
            if (existing && existing.blob && existing.blob.size > 0) {
                showDoneState(existing.blob);
            } else {
                showReadyState();
            }
        }

        // --- ANIMATED MODAL LOGIC (iOS FLIP Style) ---
        
        async function openClipModal(clipOrDate, triggerEl = null) {
            let clip;
            let date;

            if (typeof clipOrDate === 'string') {
                date = clipOrDate;
                clip = await getClip(date, APP.mode);
            } else {
                clip = clipOrDate;
                date = clip.date;
            }

            if (!clip || !clip.blob || clip.blob.size === 0) {
                triggerSearchError("Error: Valid recording not found");
                return;
            }
            
            activeTriggerEl = triggerEl;

            try {
                // Setup Video
                const file = new File([clip.blob], "preview.webm", { type: clip.blob.type });
                DOM.modalVideo.src = URL.createObjectURL(file);
                DOM.modalDateDisplay.textContent = formatDateDisplay(date);
                
                if (clip.timestamp) {
                    DOM.modalTimeDisplay.textContent = formatTimeDisplay(clip.timestamp);
                    DOM.modalTimeDisplay.classList.remove('hidden');
                } else {
                    DOM.modalTimeDisplay.classList.add('hidden');
                }

                // Prepare for Animation
                DOM.clipModal.classList.remove('hidden', 'modal-hidden');
                DOM.clipModal.classList.add('flex');
                
                const modalContent = DOM.clipModal.firstElementChild;

                if (triggerEl) {
                    // FLIP Animation Logic
                    const triggerRect = triggerEl.getBoundingClientRect();
                    const modalRect = modalContent.getBoundingClientRect();

                    // Calculate scales
                    const scaleX = triggerRect.width / modalRect.width;
                    const scaleY = triggerRect.height / modalRect.height;
                    
                    const translateX = triggerRect.left - modalRect.left;
                    const translateY = triggerRect.top - modalRect.top;

                    // Apply Initial State (Instant)
                    modalContent.style.transition = 'none';
                    modalContent.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
                    
                    // FIX: START FULLY OPAQUE to act as the expanded element
                    modalContent.style.opacity = '1'; 
                    modalContent.style.borderRadius = '1.25rem'; 
                    modalContent.style.padding = '2rem'; // ADDED: Start with padding for symmetry

                    // UPDATED: Disable transition on trigger momentarily to prevent fade out on open
                    triggerEl.style.transition = 'none';
                    triggerEl.classList.add('animating-source');
                    // Force reflow
                    triggerEl.offsetHeight;
                    triggerEl.style.transition = '';

                    // Force Reflow
                    modalContent.offsetHeight; 

                    // Play Animation to Final State
                    requestAnimationFrame(() => {
                        modalContent.style.transition = ''; 
                        modalContent.style.transform = 'translate(0, 0) scale(1, 1)';
                        modalContent.style.opacity = '1';
                        modalContent.style.borderRadius = '2rem'; 
                        modalContent.style.padding = '0'; // ADDED: Animate padding to 0
                    });

                } else {
                    // Fallback for non-grid opens (search, review after recording)
                    modalContent.style.transition = 'none';
                    modalContent.style.transform = 'scale(0.95)';
                    modalContent.style.opacity = '0';
                    modalContent.offsetHeight;
                    
                    requestAnimationFrame(() => {
                        modalContent.style.transition = '';
                        modalContent.style.transform = 'scale(1)';
                        modalContent.style.opacity = '1';
                    });
                }
                
                // --- Attach Action Handlers ---
                
                DOM.btnDownloadClip.onclick = async () => {
                    if (DOM.btnDownloadClip.disabled) return;
                    vibrate(HAPTIC.tap);
                    
                    DOM.btnDownloadClip.disabled = true;
                    DOM.dlIconContainer.classList.add('hidden');
                    DOM.dlSpinner.classList.remove('hidden');

                    try {
                        const watermarkedBlob = await processWatermarkedDownload(clip.blob, clip.date, APP.mode);
                        const safeMode = clip.mode || APP.mode;
                        const safeName = getSafeUsername();
                        const fileName = `${safeName}_${safeMode}_${formatDateDisplay(date)}.webm`;
                        downloadFile(watermarkedBlob, fileName);
                    } catch (err) {
                        console.error("Watermark download failed", err);
                        alert("Failed to process download. Please try again.");
                    } finally {
                        DOM.btnDownloadClip.disabled = false;
                        DOM.dlIconContainer.classList.remove('hidden');
                        DOM.dlSpinner.classList.add('hidden');
                    }
                };

            } catch (e) {
                console.error("Error displaying video", e);
                DOM.statusText.textContent = "Error: Video unavailable";
                return;
            }
            
            DOM.btnDeleteClip.onclick = async () => {
                if (DOM.btnDeleteClip.dataset.state === 'confirm') {
                    vibrate(HAPTIC.destructive);
                    await deleteClip(date, APP.mode);
                    
                    // Simple close for delete, no morph back needed as item is gone
                    DOM.clipModal.classList.add('hidden', 'modal-hidden'); 
                    DOM.clipModal.classList.remove('flex');
                    if(activeTriggerEl) activeTriggerEl.classList.remove('animating-source');
                    
                    await renderCalendar();
                    setTargetDate(APP.today);
                    resetDeleteBtn();
                } else {
                    vibrate(HAPTIC.warning);
                    DOM.btnDeleteClip.dataset.state = 'confirm';
                    DOM.btnDeleteClip.innerHTML = '<div class="w-4 h-4 flex items-center justify-center"><span class="text-red-400 font-extrabold text-sm">?</span></div>';
                    setTimeout(() => {
                        if (DOM.btnDeleteClip.dataset.state === 'confirm') resetDeleteBtn();
                    }, 3000);
                }
            };

            DOM.btnReplaceClip.onclick = () => {
                vibrate(HAPTIC.tap); 
                closeModal(); // Morph back
                setTimeout(() => {
                    APP.targetDate = date;
                    DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
                    DOM.targetIndicator.classList.remove('hidden');
                    DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;
                    showReadyState();
                }, 400); 
            };
        }
        
        function resetDeleteBtn() {
            DOM.btnDeleteClip.dataset.state = '';
            DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>';
            lucide.createIcons();
        }
        
        // UPDATED: Closing Sequence with Cross-fade Logic
        function closeModal() {
            vibrate(HAPTIC.tap);
            DOM.modalVideo.pause();
            
            if (activeTriggerEl) {
                const modalContent = DOM.clipModal.firstElementChild;
                const modalRect = modalContent.getBoundingClientRect();
                const triggerRect = activeTriggerEl.getBoundingClientRect();

                const scaleX = triggerRect.width / modalRect.width;
                const scaleY = triggerRect.height / modalRect.height;
                const translateX = triggerRect.left - modalRect.left;
                const translateY = triggerRect.top - modalRect.top;

                // PHASE 1: Morph Only (Keep Opacity 1)
                // Explicitly set transition for transform/radius/padding only - override default CSS
                modalContent.style.transition = 'transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), border-radius 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), padding 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
                modalContent.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
                modalContent.style.borderRadius = '1.25rem';
                modalContent.style.padding = '2rem'; // ADDED: Padding transition target
                modalContent.style.opacity = '1';

                // Fade out the black backdrop immediately though
                DOM.clipModal.classList.add('modal-hidden');

                // PHASE 2: Cross-fade (Triggered after morph completes)
                setTimeout(() => {
                    // 1. Reveal Badge (Fade In)
                    // Ensure the badge has a smooth opacity transition (added in CSS)
                    activeTriggerEl.classList.remove('animating-source');

                    // 2. Hide Modal (Fade Out)
                    modalContent.style.transition = 'opacity 0.2s ease';
                    modalContent.style.opacity = '0';

                    // PHASE 3: Cleanup (After Fade)
                    setTimeout(() => {
                        // Check if cancelled by quick reopen
                        if(!DOM.clipModal.classList.contains('modal-hidden')) return;

                        DOM.clipModal.classList.remove('flex');
                        DOM.clipModal.classList.add('hidden');
                        
                        // Reset styles
                        modalContent.style.transform = '';
                        modalContent.style.opacity = '';
                        modalContent.style.borderRadius = '';
                        modalContent.style.transition = '';
                        modalContent.style.padding = '';
                        
                        activeTriggerEl = null;
                        resetDeleteBtn();
                    }, 200); // Wait for opacity fade out

                }, 500); // Wait for morph transform

            } else {
                // Fallback for non-grid closes
                DOM.clipModal.classList.add('modal-hidden');
                setTimeout(() => {
                    DOM.clipModal.classList.add('hidden');
                    DOM.clipModal.classList.remove('flex');
                    resetDeleteBtn();
                }, 400);
            }
        }

        DOM.btnCloseClip.addEventListener('click', closeModal);

        // --- CAMERA & FLASH LOGIC ---
        
        DOM.btnInit.addEventListener('click', () => { 
            vibrate(HAPTIC.action); 
            startCamera(); 
        });
        
        DOM.btnSwitchCam.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.sceneCamFacing = APP.sceneCamFacing === 'environment' ? 'user' : 'environment';
            startCamera();
        });

        DOM.btnFlash.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            toggleFlashState();
        });

        function toggleFlashState() {
            APP.flashEnabled = !APP.flashEnabled;
            updateFlashUI();
        }

        function updateFlashUI() {
            if (APP.flashEnabled) {
                DOM.btnFlash.classList.replace('text-slate-300', 'text-yellow-400');
                DOM.iconFlash.setAttribute('data-lucide', 'zap');
            } else {
                DOM.btnFlash.classList.replace('text-yellow-400', 'text-slate-300');
                DOM.iconFlash.setAttribute('data-lucide', 'zap-off');
            }
            lucide.createIcons();
        }

        async function applyTorch(state) {
            if (APP.hasTorch && APP.trackRef) {
                try {
                    await APP.trackRef.applyConstraints({ advanced: [{ torch: state }] });
                } catch (e) {
                    console.warn("Torch failed", e);
                }
            }
        }

        async function startCamera() {
             if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                DOM.statusText.textContent = "Error: HTTPS Required";
                return;
            }

            if (APP.cameraStream) {
                APP.cameraStream.getTracks().forEach(t => t.stop());
                if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.statusText.textContent = "Starting camera...";
            let constraints = { 
                audio: true, 
                video: {
                    facingMode: APP.mode === 'self' ? 'user' : { ideal: APP.sceneCamFacing }
                } 
            };

            try {
                APP.cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                DOM.cameraPreview.srcObject = APP.cameraStream;
                await DOM.cameraPreview.play();
                DOM.cameraPreview.classList.remove('hidden');
                DOM.playbackPreview.classList.add('hidden');
                DOM.startOverlay.classList.add('opacity-0', 'pointer-events-none');
                DOM.recordControls.classList.remove('hidden');
                DOM.statusText.textContent = `Ready (${APP.mode})`;
                DOM.statusText.classList.remove('opacity-0');
                
                if (APP.mode === 'self') {
                    DOM.cameraPreview.classList.add('mirrored');
                } else {
                    DOM.cameraPreview.classList.remove('mirrored');
                }

                DOM.btnFlash.classList.remove('hidden');
                if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');

                const track = APP.cameraStream.getVideoTracks()[0];
                APP.trackRef = track;
                const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                APP.hasTorch = !!capabilities.torch;
                
                updateCanvasLoop();

            } catch (err) {
                console.error(err);
                DOM.statusText.textContent = "Error: " + err.name;
            }
        }

        // --- NEW: CLEAN RECORDING LOOP ---
        function updateCanvasLoop() {
            const ctx = DOM.processingCanvas.getContext('2d');
            const video = DOM.cameraPreview;
            const canvas = DOM.processingCanvas;

            function draw() {
                if (video.readyState >= 2) { 
                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    
                    if (canvas.width !== vw || canvas.height !== vh) {
                        canvas.width = vw;
                        canvas.height = vh;
                    }

                    const cw = canvas.width;
                    const ch = canvas.height;

                    ctx.save();
                    if (APP.mode === 'self') {
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(video, 0, 0, cw, ch);
                    ctx.restore();
                }
                APP.animationId = requestAnimationFrame(draw);
            }
            draw();
        }

        // --- NEW: WATERMARK LOGIC ISOLATED & FIXES ---
        
        // Helper: Pure path definition (no beginPath inside)
        function drawRoundedRectPath(ctx, x, y, w, h, r) {
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r); // Top-right
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); // Bottom-right
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); // Bottom-left (FIXED)
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y); // Top-left
        }

        // UPDATED: Now accepts sourceElement (the video) to enable blur effect
        function drawWatermark(ctx, cw, ch, dateString, sourceElement) {
            ctx.save(); // Protect context

            const margin = cw * 0.04;
            const boxHeight = cw * 0.065;
            const boxRadius = boxHeight / 2;
            const fontSize = boxHeight * 0.45;
            const paddingX = boxHeight * 0.5;
            
            // Robust Date Parsing
            let y, m, d;
            if (dateString && dateString.includes('-')) {
                 [y, m, d] = dateString.split('-');
            } else {
                 const now = new Date();
                 y = now.getFullYear(); m = now.getMonth()+1; d = now.getDate();
            }
            
            const dateObj = new Date(Number(y), Number(m)-1, Number(d));
            const dateText = dateObj.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }).toUpperCase();
            const dayNum = getDayOfYear(dateObj);
            const dayText = `DAY ${dayNum}`;

            ctx.font = `700 ${fontSize}px "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
            const logoSize = boxHeight * 0.6;
            const gap = boxHeight * 0.4;
            
            const leftTextWidth = ctx.measureText(dateText).width;
            const leftBoxWidth = paddingX + logoSize + gap + leftTextWidth + paddingX;
            const leftBoxX = margin;
            const leftBoxY = ch - margin - boxHeight;

            const rightTextWidth = ctx.measureText(dayText).width;
            const rightBoxWidth = paddingX + rightTextWidth + paddingX;
            const rightBoxX = cw - margin - rightBoxWidth;
            const rightBoxY = ch - margin - boxHeight;

            // Updated overlay opacity for subtle look (0.3)
            const overlayColor = 'rgba(15, 23, 42, 0.3)'; 
            const textColor = '#cbcbcb'; 
            
            // --- LEFT BOX (With Blur) ---
            ctx.save();
            ctx.beginPath(); 
            drawRoundedRectPath(ctx, leftBoxX, leftBoxY, leftBoxWidth, boxHeight, boxRadius); 
            ctx.clip(); // Clip to box shape

            if (sourceElement) {
                ctx.filter = 'blur(8px)'; // The blurred background effect
                // Draw video again, clipped to this box. 
                // Since canvas matches video size, 0,0 is correct.
                ctx.drawImage(sourceElement, 0, 0, cw, ch);
            }
            ctx.filter = 'none'; // Reset filter
            ctx.fillStyle = overlayColor;
            ctx.fill(); // Fill subtle overlay
            ctx.restore();

            // --- RIGHT BOX (With Blur) ---
            ctx.save();
            ctx.beginPath(); 
            drawRoundedRectPath(ctx, rightBoxX, rightBoxY, rightBoxWidth, boxHeight, boxRadius); 
            ctx.clip();

            if (sourceElement) {
                ctx.filter = 'blur(8px)';
                ctx.drawImage(sourceElement, 0, 0, cw, ch);
            }
            ctx.filter = 'none';
            ctx.fillStyle = overlayColor;
            ctx.fill();
            ctx.restore();

            // --- CONTENT (Text/Icon) ---
            const iconY = leftBoxY + (boxHeight - logoSize) / 2;
            const iconX = leftBoxX + paddingX;
            
            if (APP.logoImg && APP.logoImg.complete && APP.logoImg.naturalHeight !== 0) {
                ctx.drawImage(APP.logoImg, iconX, iconY, logoSize, logoSize);
            }
            
            ctx.fillStyle = textColor;
            ctx.textBaseline = 'middle';
            ctx.fillText(dateText, iconX + logoSize + gap, leftBoxY + (boxHeight / 2) + (fontSize * 0.05));
            ctx.fillText(dayText, rightBoxX + paddingX, rightBoxY + (boxHeight / 2) + (fontSize * 0.05));
            
            ctx.restore();
        }

        // --- FIXED: POST-PROCESS WATERMARK DOWNLOADER (NO FREEZE) ---
        async function processWatermarkedDownload(cleanBlob, dateString, mode) {
            try {
                // Create video element
                const video = document.createElement('video');
                video.src = URL.createObjectURL(cleanBlob);
                video.muted = false; // Must be false to capture audio via createMediaElementSource
                video.playsInline = true;
                video.crossOrigin = "anonymous";
                
                // CRITICAL FIX: Append to DOM (hidden) so rAF works reliably
                video.style.position = 'absolute';
                video.style.top = '0';
                video.style.left = '0';
                video.style.opacity = '0';
                video.style.pointerEvents = 'none';
                video.style.zIndex = '-100';
                document.body.appendChild(video);
                
                // Step 1: Wait for video metadata to load
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                    setTimeout(() => reject(new Error('Video metadata load timeout')), 10000);
                });
                
                // Step 2: Seek to first valid frame (0.033s â‰ˆ 1 frame at 30fps)
                video.currentTime = 0.033;
                
                // Wait for seek to complete
                await new Promise((resolve, reject) => {
                    video.onseeked = resolve;
                    video.onerror = reject;
                    setTimeout(() => reject(new Error('Video seek timeout')), 5000);
                });
                
                // Step 3: Wait for frame data to be fully decoded
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (video.readyState >= 2) { // HAVE_CURRENT_DATA or better
                            resolve();
                        } else {
                            setTimeout(checkReady, 50);
                        }
                    };
                    checkReady();
                });
                
                // Step 4: Additional buffer to ensure frame is fully ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Step 5: Validate video dimensions
                const w = video.videoWidth;
                const h = video.videoHeight;
                
                if (w === 0 || h === 0) {
                    throw new Error('Invalid video dimensions');
                }
                
                // Setup canvas
                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                
                // Step 6: Draw and validate first frame
                ctx.drawImage(video, 0, 0, w, h);
                drawWatermark(ctx, w, h, dateString, video);
                
                // Verify canvas isn't blank by sampling center pixel
                const imageData = ctx.getImageData(w / 2, h / 2, 1, 1);
                const isBlank = imageData.data[0] === 0 && imageData.data[1] === 0 && imageData.data[2] === 0;
                
                if (isBlank) {
                    // Retry drawing after one more frame delay
                    await new Promise(resolve => setTimeout(resolve, 100));
                    ctx.drawImage(video, 0, 0, w, h);
                    drawWatermark(ctx, w, h, dateString, video);
                }
                
                // Step 7: Setup canvas stream (BEFORE starting recorder)
                const stream = canvas.captureStream(30);
                
                // Step 8: Setup audio pass-through
                let audioContext, sourceNode, audioDest;
                if (cleanBlob.type.includes('webm') || cleanBlob.type.includes('mp4')) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        // Resume if suspended (critical for mobile)
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        
                        sourceNode = audioContext.createMediaElementSource(video);
                        audioDest = audioContext.createMediaStreamDestination();
                        sourceNode.connect(audioDest);
                        const audioTrack = audioDest.stream.getAudioTracks()[0];
                        if (audioTrack) stream.addTrack(audioTrack);
                    } catch(e) { 
                        console.warn("Audio context failed", e); 
                    }
                }
                
                // Step 9: Setup MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                    ? 'video/webm; codecs=vp9' 
                    : 'video/webm';
                
                const recorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000 
                });
                
                const chunks = [];
                recorder.ondataavailable = e => { 
                    if (e.data.size > 0) chunks.push(e.data); 
                };
                
                // Step 10: Define render loop with freeze prevention
                let renderLoopActive = false;
                let renderFrameId = null;
                const videoDuration = video.duration;
                // FIX: Removed the threshold that caused early freeze
                // const stopThreshold = videoDuration - 0.05; 
                
                const requestFrame = (cb) => {
                    if (video.requestVideoFrameCallback) {
                        renderFrameId = video.requestVideoFrameCallback(cb);
                    } else {
                        renderFrameId = requestAnimationFrame(cb);
                    }
                };
                
                const cancelFrame = () => {
                    if (renderFrameId !== null) {
                        if (video.cancelVideoFrameCallback) {
                            video.cancelVideoFrameCallback(renderFrameId);
                        } else {
                            cancelAnimationFrame(renderFrameId);
                        }
                        renderFrameId = null;
                    }
                };
                
                function renderLoop() {
                    // FIX: Stop ONLY when explicitly ended or paused, no artificial threshold
                    if (!renderLoopActive || video.paused || video.ended) {
                        renderLoopActive = false;
                        cancelFrame();
                        return;
                    }
                    
                    ctx.drawImage(video, 0, 0, w, h);
                    drawWatermark(ctx, w, h, dateString, video);
                    
                    requestFrame(renderLoop);
                }
                
                // Step 11: Reset video to start for final playback
                video.currentTime = 0;
                await new Promise(resolve => {
                    video.onseeked = resolve;
                    setTimeout(resolve, 100); // Fallback
                });

                // FIX: Start Recorder FIRST to capture the very first frame (Step 6 result)
                // This prevents cutting the first 150ms of the video
                recorder.start();
                
                // Step 12: Start playback
                // Use a try-catch for play() as it can be flaky if not user-initiated
                try {
                    await video.play();
                } catch (e) { console.error("Play error", e); }
                
                renderLoopActive = true;
                renderLoop();
                
                // Step 16: Wait for video to complete with proper cleanup
                await new Promise((resolve, reject) => {
                    video.onended = () => {
                        renderLoopActive = false;
                        cancelFrame(); // Cancel any pending frames
                        
                        // Small delay to ensure last valid frame is captured
                        setTimeout(() => {
                            recorder.stop();
                            resolve();
                        }, 50);
                    };
                    video.onerror = (e) => {
                        console.error("Video playback error", e);
                        renderLoopActive = false;
                        cancelFrame();
                        reject(e);
                    };
                });
                
                // Step 17: Wait for recorder to finish
                await new Promise(resolve => {
                    recorder.onstop = resolve;
                    setTimeout(resolve, 1000); // Fallback timeout
                });
                
                // Step 18: Cleanup
                if (audioContext) {
                    try { await audioContext.close(); } catch(e) {}
                }
                document.body.removeChild(video);
                URL.revokeObjectURL(video.src);
                
                // Step 19: Create and return final blob
                if (chunks.length === 0) {
                    throw new Error('No video data recorded');
                }
                
                return new Blob(chunks, { type: 'video/webm' });
                
            } catch (error) {
                console.error('processWatermarkedDownload error:', error);
                
                // Cleanup on error
                const videos = document.querySelectorAll('video[style*="z-index: -100"]');
                videos.forEach(v => {
                    try {
                        if (v.parentNode) document.body.removeChild(v);
                        if (v.src) URL.revokeObjectURL(v.src);
                    } catch(e) {}
                });
                
                throw error;
            }
        }


        // --- RECORDING LIFECYCLE ---
        
        DOM.btnRecord.addEventListener('click', () => {
            vibrate(HAPTIC.success);
            startRecording();
        });

        async function startRecording() {
            if (!APP.cameraStream) return;
            
            DOM.btnRecord.disabled = true;
            DOM.recIcon.classList.replace('rounded-sm', 'rounded-full');
            DOM.recIcon.classList.add('animate-pulse');
            DOM.statusText.textContent = "Recording...";
            APP.recordedChunks = [];

            if (APP.flashEnabled) {
                if (APP.hasTorch) {
                    applyTorch(true);
                } else {
                    DOM.cameraContainer.classList.add('flash-active');
                }
            }

            const mimeOptions = ["video/webm;codecs=vp8", "video/webm", "video/mp4"];
            const selectedMime = mimeOptions.find(type => MediaRecorder.isTypeSupported(type));

            try {
                const canvasStream = DOM.processingCanvas.captureStream(30); 
                
                if (APP.cameraStream.getAudioTracks().length > 0) {
                    APP.recAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const source = APP.recAudioCtx.createMediaStreamSource(APP.cameraStream);
                    const dest = APP.recAudioCtx.createMediaStreamDestination();
                    source.connect(dest);
                    const audioTrack = dest.stream.getAudioTracks()[0];
                    canvasStream.addTrack(audioTrack);
                }

                APP.mediaRecorder = new MediaRecorder(canvasStream, { 
                    mimeType: selectedMime,
                    videoBitsPerSecond: 2500000 
                });
            } catch (e) {
                DOM.statusText.textContent = "Rec Error: " + e.message;
                return;
            }

            APP.mediaRecorder.ondataavailable = (e) => { 
                if (e.data && e.data.size > 0) APP.recordedChunks.push(e.data); 
            };
            
            APP.mediaRecorder.onstop = async () => {
                if (APP.mediaRecorder.stream) {
                    APP.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }

                if (APP.recAudioCtx) {
                    try { await APP.recAudioCtx.close(); } catch(e) {}
                    APP.recAudioCtx = null;
                }

                if (APP.flashEnabled) {
                    if (APP.hasTorch) {
                        applyTorch(false);
                    } else {
                        DOM.cameraContainer.classList.remove('flash-active');
                    }
                }

                const blob = new Blob(APP.recordedChunks, { type: selectedMime.split(';')[0] });
                
                if (blob.size < 5000) {
                    DOM.statusText.textContent = "Error: File too small. Try again.";
                    vibrate(HAPTIC.warning);
                    setTimeout(() => resetRecorderUI(), 2000);
                    return;
                }

                await handleRecordingComplete(blob);
            };

            const recordDuration = APP.mode === 'scene' ? 3000 : 1000;
            
            // FIX: Add delay for Flash Stabilization
            // If flash is enabled, wait 400ms for camera AE/AWB to settle before recording
            const startDelay = APP.flashEnabled ? 400 : 0;

            setTimeout(() => {
                APP.mediaRecorder.start(); 

                const circumference = 45 * 2 * Math.PI;
                DOM.progressCircle.style.strokeDashoffset = circumference;
                
                // Reset transition to ensure smooth start after delay
                DOM.progressCircle.style.transition = 'none';
                DOM.progressCircle.style.strokeDashoffset = circumference;
                
                // Start animation in next frame
                requestAnimationFrame(() => {
                    DOM.progressCircle.style.transition = `stroke-dashoffset ${recordDuration/1000}s linear`;
                    DOM.progressCircle.style.strokeDashoffset = '0';
                });

                setTimeout(() => {
                    if (APP.mediaRecorder.state === 'recording') APP.mediaRecorder.stop();
                }, recordDuration);
                
            }, startDelay);
        }

        async function handleRecordingComplete(cleanBlob) {
            // 1. Save CLEAN version to DB
            await saveClip(APP.targetDate, APP.mode, cleanBlob);
            
            // 2. Prepare Watermarked Download (Robust Fallback System)
            DOM.statusText.textContent = "Processing Download...";
            
            try {
                // Wrap total operation in a master timeout (30 seconds max)
                const watermarkedBlob = await withTimeout(
                    processWatermarkedDownload(cleanBlob, APP.targetDate, APP.mode),
                    30000, 
                    "Total processing time exceeded"
                );
                
                const safeName = getSafeUsername();
                downloadFile(watermarkedBlob, `${safeName}_${APP.mode}_${formatDateDisplay(APP.targetDate)}.webm`);
                DOM.statusText.textContent = "Saved.";
                
            } catch(e) {
                console.error("Watermark processing failed:", e);
                
                // FALLBACK: Download the original clean video
                // This prevents data loss when processing hangs/fails
                DOM.statusText.textContent = "Processing Failed. Saved Original.";
                vibrate(HAPTIC.warning);
                
                const safeName = getSafeUsername();
                // Append '_raw' to distinguish
                downloadFile(cleanBlob, `${safeName}_${APP.mode}_${formatDateDisplay(APP.targetDate)}_raw.webm`);
                
                // Show a non-blocking toast/alert (simulated via existing UI or alert)
                setTimeout(() => {
                    alert(`Processing failed (${e.message}). Downloading original video instead.`);
                }, 500);
            }

            await renderCalendar();
            showDoneState(cleanBlob); // Show CLEAN video in preview
            vibrate(HAPTIC.success);
        }

        function showDoneState(blob) {
            if(APP.cameraStream) {
               APP.cameraStream.getTracks().forEach(t => t.stop());
               APP.cameraStream = null;
               if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.playbackPreview.src = URL.createObjectURL(blob);
            DOM.playbackPreview.classList.remove('hidden');
            DOM.cameraPreview.classList.add('hidden');
            DOM.doneOverlay.classList.remove('hidden');
            DOM.recordControls.classList.add('hidden');
            DOM.btnFlash.classList.add('hidden');
            DOM.btnSwitchCam.classList.add('hidden');
            DOM.statusText.textContent = "Saved.";
            
            DOM.btnViewClip.onclick = () => {
                vibrate(HAPTIC.tap);
                // openClipModal handles logic for "Review"
                // We pass the blob directly to avoid DB fetch lag
                const tempClip = { date: APP.targetDate, mode: APP.mode, blob: blob };
                openClipModal(tempClip);
            };
        }
        
        function resetRecorderUI() {
             DOM.doneOverlay.classList.add('hidden');
             DOM.playbackPreview.classList.add('hidden');
             DOM.cameraPreview.classList.remove('hidden');
             
             if (!APP.cameraStream) {
                 DOM.recordControls.classList.add('hidden');
                 DOM.startOverlay.classList.remove('opacity-0', 'pointer-events-none');
                 DOM.btnFlash.classList.add('hidden');
                 DOM.btnSwitchCam.classList.add('hidden');
                 DOM.statusText.textContent = "Ready";
             } else {
                 DOM.recordControls.classList.remove('hidden');
                 DOM.btnFlash.classList.remove('hidden');
                 if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');
             }
             
             showReadyState();
        }

        function showReadyState() {
            DOM.doneOverlay.classList.add('hidden');
            DOM.playbackPreview.classList.add('hidden');
            DOM.cameraPreview.classList.remove('hidden');
            
            DOM.progressCircle.style.transition = 'none';
            DOM.progressCircle.style.strokeDashoffset = 45 * 2 * Math.PI;
            DOM.btnRecord.disabled = false;
            DOM.recIcon.classList.replace('rounded-full', 'rounded-sm');
            DOM.recIcon.classList.remove('animate-pulse');
        }

        // --- COMPILATION CORE (CONTEXT AWARE) ---
        
        // Month View Music Input Handler
        DOM.monthMusicInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Update State
                APP.musicConfig.file = file;
                APP.musicConfig.start = 0;
                APP.musicConfig.end = null;
                
                // Get Duration for later
                const tempAudio = new Audio(URL.createObjectURL(file));
                tempAudio.onloadedmetadata = () => {
                    APP.musicConfig.duration = tempAudio.duration;
                    APP.musicConfig.end = tempAudio.duration;
                };

                // Update UI
                DOM.monthMusicText.textContent = file.name;
                
                // Active Styling
                DOM.monthMusicWrapper.classList.add('border-rose-500/50', 'bg-slate-700/30');
                DOM.monthMusicWrapper.classList.remove('border-slate-700', 'bg-slate-800');
                
                DOM.monthMusicIcon.classList.add('text-rose-400');
                DOM.monthMusicText.classList.add('text-white');
                DOM.monthMusicText.classList.remove('text-slate-400');
                
                // Show Controls
                DOM.btnRemoveMonthMusic.classList.remove('hidden');
                DOM.btnTrimMusic.classList.remove('hidden');
                DOM.musicDivider.classList.remove('hidden');
                
                vibrate(HAPTIC.success);
            }
        });

        // --- NEW: INSTAGRAM-STYLE TRIM LOGIC ---

        async function calculateMonthDuration() {
            const clips = await getAllClips(APP.mode);
            const year = APP.viewDate.getFullYear();
            const month = String(APP.viewDate.getMonth() + 1).padStart(2, '0');
            const monthPrefix = `${year}-${month}`;
            const monthClips = clips.filter(c => c.date.startsWith(monthPrefix));
            
            // Self mode = ~1s, Scene mode = ~3s
            const clipDuration = APP.mode === 'scene' ? 3 : 1;
            return {
                duration: monthClips.length * clipDuration,
                count: monthClips.length
            };
        }

        function updateTrimUI(startTime) {
            // Clamp start time
            const maxStart = Math.max(0, APP.trimState.songDuration - APP.trimState.videoDuration);
            if (startTime < 0) startTime = 0;
            if (startTime > maxStart) startTime = maxStart;

            // Calculate visual position percentage
            const pct = (startTime / APP.trimState.songDuration) * 100;
            DOM.trimWindow.style.left = `${pct}%`;

            // Update displays
            DOM.trimStartDisplay.textContent = `${startTime.toFixed(1)}s`;
            const end = Math.min(startTime + APP.trimState.videoDuration, APP.trimState.songDuration);
            DOM.trimEndDisplay.textContent = `${end.toFixed(1)}s`;
            
            // Update Config temporarily (so preview works)
            APP.musicConfig.start = startTime;
            APP.musicConfig.end = end;
        }

        // Trim Button Handler (Entry Point)
        DOM.btnTrimMusic.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!APP.musicConfig.file) return;

            // 1. Get Video Stats
            const stats = await calculateMonthDuration();
            APP.trimState.videoDuration = stats.duration || 1; // Prevent 0 division
            DOM.trimTotalTime.textContent = `Video Length: ${stats.duration}s`;
            DOM.trimClipCount.textContent = stats.count;

            if (stats.count === 0) {
                alert("No clips recorded for this month yet!");
                return;
            }

            // 2. Setup Audio
            const fileURL = URL.createObjectURL(APP.musicConfig.file);
            DOM.trimAudioPreview.src = fileURL;
            
            // 3. Initialize UI once metadata loads
            DOM.trimAudioPreview.onloadedmetadata = () => {
                APP.trimState.songDuration = DOM.trimAudioPreview.duration;
                
                // Logic: How wide should the window be?
                // window width % = (videoDuration / songDuration) * 100
                let windowPct = (APP.trimState.videoDuration / APP.trimState.songDuration) * 100;
                
                // Cap at 100% if video is longer than song (will loop)
                if (windowPct > 100) windowPct = 100;
                
                DOM.trimWindow.style.width = `${windowPct}%`;
                
                // Restore previous start position or default to 0
                updateTrimUI(APP.musicConfig.start || 0);
                
                DOM.trimModal.classList.remove('hidden');
                DOM.trimModal.classList.add('flex');
            };
            
            DOM.trimAudioPreview.load();
            vibrate(HAPTIC.tap);
        });

        // --- DRAG HANDLERS ---
        
        const handleDragStart = (clientX) => {
            APP.trimState.isDragging = true;
            APP.trimState.startX = clientX;
            // Get current left % from style, convert to pixels
            const rect = DOM.trimTrackContainer.getBoundingClientRect();
            APP.trimState.containerWidth = rect.width;
            
            // Calculate current visual left in pixels
            const currentLeftPct = parseFloat(DOM.trimWindow.style.left || 0);
            APP.trimState.currentLeft = (currentLeftPct / 100) * rect.width;
            
            DOM.trimWindow.classList.add('cursor-grabbing');
            DOM.trimWindow.classList.remove('cursor-grab');
            
            // Pause if dragging
            if (APP.trimState.isPlaying) pausePreview();
        };

        const handleDragMove = (clientX) => {
            if (!APP.trimState.isDragging) return;
            
            const deltaX = clientX - APP.trimState.startX;
            let newLeftPx = APP.trimState.currentLeft + deltaX;
            
            // Convert pixel to time
            // Time = (LeftPx / ContainerWidth) * SongDuration
            let newStartTime = (newLeftPx / APP.trimState.containerWidth) * APP.trimState.songDuration;
            
            updateTrimUI(newStartTime);
        };

        const handleDragEnd = () => {
            if (!APP.trimState.isDragging) return;
            APP.trimState.isDragging = false;
            DOM.trimWindow.classList.remove('cursor-grabbing');
            DOM.trimWindow.classList.add('cursor-grab');
        };

        // Mouse Events
        DOM.trimTrackContainer.addEventListener('mousedown', (e) => handleDragStart(e.clientX));
        window.addEventListener('mousemove', (e) => handleDragMove(e.clientX));
        window.addEventListener('mouseup', handleDragEnd);

        // Touch Events
        DOM.trimTrackContainer.addEventListener('touchstart', (e) => {
            // e.preventDefault(); // allow scroll if needed, but here we want drag
            handleDragStart(e.touches[0].clientX);
        }, { passive: false });
        
        window.addEventListener('touchmove', (e) => {
             // e.preventDefault(); 
             handleDragMove(e.touches[0].clientX);
        }, { passive: false });
        
        window.addEventListener('touchend', handleDragEnd);


        // --- PREVIEW LOGIC (FIXED) ---

        function togglePreview() {
            if (APP.trimState.isPlaying) {
                pausePreview();
            } else {
                playPreview();
            }
        }

        function playPreview() {
            // Set Start Time
            DOM.trimAudioPreview.currentTime = APP.musicConfig.start;
            
            // Play
            DOM.trimAudioPreview.play().then(() => {
                APP.trimState.isPlaying = true;
                updatePreviewIcon();
                startProgressLoop(); // Start visual progress
                
                // Duration Logic: Play FULL selected segment (video duration)
                const duration = APP.trimState.videoDuration * 1000;
                
                if (APP.trimState.previewTimeout) clearTimeout(APP.trimState.previewTimeout);
                
                APP.trimState.previewTimeout = setTimeout(() => {
                    pausePreview();
                }, duration);

            }).catch(e => console.error("Preview play failed", e));
        }

        function pausePreview() {
            DOM.trimAudioPreview.pause();
            APP.trimState.isPlaying = false;
            updatePreviewIcon();
            stopProgressLoop(); // Stop visual progress
            if (APP.trimState.previewTimeout) clearTimeout(APP.trimState.previewTimeout);
        }

        // Fixed: Re-inject HTML to ensure Lucide renders correctly every time
        function updatePreviewIcon() {
            const iconName = APP.trimState.isPlaying ? 'pause' : 'play';
            DOM.btnPreviewTrimSegment.innerHTML = `<i data-lucide="${iconName}" class="w-4 h-4"></i>`;
            lucide.createIcons();
        }

        // New: Progress Bar Animation Loop
        function startProgressLoop() {
            const draw = () => {
                if (!APP.trimState.isPlaying) return;
                
                const current = DOM.trimAudioPreview.currentTime;
                const start = APP.musicConfig.start;
                const duration = APP.trimState.videoDuration;

                // Calculate progress relative to the selected segment
                let pct = ((current - start) / duration) * 100;
                
                // Clamp
                if (pct < 0) pct = 0;
                if (pct > 100) pct = 100;

                DOM.trimProgressBar.style.width = `${pct}%`;
                
                APP.trimState.progressFrameId = requestAnimationFrame(draw);
            };
            
            if (APP.trimState.progressFrameId) cancelAnimationFrame(APP.trimState.progressFrameId);
            APP.trimState.progressFrameId = requestAnimationFrame(draw);
        }

        function stopProgressLoop() {
            if (APP.trimState.progressFrameId) cancelAnimationFrame(APP.trimState.progressFrameId);
            DOM.trimProgressBar.style.width = '0%';
        }

        // Preview Button
        DOM.btnPreviewTrimSegment.addEventListener('click', () => {
             togglePreview();
        });

        // Save Trim
        DOM.btnSaveTrim.addEventListener('click', () => {
             DOM.trimModal.classList.add('hidden');
             DOM.trimModal.classList.remove('flex');
             pausePreview(); // Stop audio
             
             // Visual feedback on main UI
             DOM.btnTrimMusic.classList.add('text-blue-400', 'bg-slate-700/50');
             DOM.btnTrimMusic.classList.remove('text-slate-500');
             
             vibrate(HAPTIC.success);
        });

        DOM.btnCancelTrim.addEventListener('click', () => {
             DOM.trimModal.classList.add('hidden');
             DOM.trimModal.classList.remove('flex');
             pausePreview();
        });

        // Remove Music Handler
        DOM.btnRemoveMonthMusic.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Clear Input & State
            DOM.monthMusicInput.value = '';
            APP.musicConfig.file = null;
            APP.musicConfig.start = 0;
            APP.musicConfig.end = null;

            // Reset UI Text
            DOM.monthMusicText.textContent = "Add Music";

            // Reset Styling
            DOM.monthMusicWrapper.classList.remove('border-rose-500/50', 'bg-slate-700/30');
            DOM.monthMusicWrapper.classList.add('border-slate-700', 'bg-slate-800');
            
            DOM.monthMusicIcon.classList.remove('text-rose-400');
            DOM.monthMusicText.classList.remove('text-white');
            DOM.monthMusicText.classList.add('text-slate-400');
            
            // Reset Trim Button Style
            DOM.btnTrimMusic.classList.remove('text-blue-400', 'bg-slate-700/50');
            DOM.btnTrimMusic.classList.add('text-slate-500');

            // Hide Controls
            DOM.btnRemoveMonthMusic.classList.add('hidden');
            DOM.btnTrimMusic.classList.add('hidden');
            DOM.musicDivider.classList.add('hidden');
            
            vibrate(HAPTIC.tap);
        });

        DOM.btnCompile.addEventListener('click', async () => {
            vibrate(HAPTIC.tap);
            const clips = await getAllClips(APP.mode);
            const year = APP.viewDate.getFullYear();
            const month = String(APP.viewDate.getMonth() + 1).padStart(2, '0');
            const monthPrefix = `${year}-${month}`;
            const monthClips = clips.filter(c => c.date.startsWith(monthPrefix));
            
            monthClips.sort((a, b) => a.date.localeCompare(b.date));

            if (monthClips.length < 2) { 
                DOM.statusText.textContent = "Needs 2+ clips to compile";
                vibrate(HAPTIC.warning);
                return; 
            }
            
            // Get Music Configuration
            const musicConfig = APP.musicConfig.file ? { ...APP.musicConfig } : null;

            // Reset UI
            DOM.compileModal.classList.remove('hidden');
            DOM.compileModal.classList.add('flex');
            DOM.btnCloseModal.classList.add('hidden');
            DOM.compileBadge.classList.remove('hidden');
            DOM.compileBadgeText.textContent = "Processing";
            
            // Apply Calm Start Styles
            DOM.compileBadge.classList.remove('text-emerald-500', 'border-emerald-500/30');
            DOM.compileBadge.classList.add('text-slate-400', 'border-slate-700/50');
            
            try { 
                // Compile internal clips using internal modal UI context
                await compileClips(monthClips, getSafeUsername(), {
                    canvas: DOM.compileCanvas,
                    progress: DOM.compileProgress,
                    log: DOM.compileLog,
                    percentEl: DOM.compilePercent
                }, true, musicConfig); // Pass music config
                
                // Success State
                DOM.btnCloseModal.classList.remove('hidden');
                DOM.compileLog.textContent = "Compilation Complete!";
                DOM.compileBadgeText.textContent = "Finished";
                
                // Apply Calm Finished Styles
                DOM.compileBadge.classList.remove('text-slate-400', 'border-slate-700/50');
                DOM.compileBadge.classList.add('text-emerald-500', 'border-emerald-500/30');
                
                vibrate(HAPTIC.success);
            }
            catch (err) { 
                DOM.compileLog.innerHTML = `<span class="text-red-400">Error: ${err.message}</span>`; 
                DOM.btnCloseModal.classList.remove('hidden'); 
                DOM.btnCloseModal.textContent = "Close";
            }
        });

        // ... (Close Modal Handlers remain same)

        // REFACTORED: accepts UI context to fix hidden canvas bug
        // Updated music handling to support AudioBuffer for trimming
        async function compileClips(items, username, uiContext, addWatermark = false, musicConfig = null) {
            const { canvas, progress, log, percentEl } = uiContext;
            
            const startDate = formatDateDisplay(items[0].date);
            const endDate = formatDateDisplay(items[items.length - 1].date);
            const mode = items[0].type || APP.mode;
            
            const outputName = `${username}_${mode}_${startDate}_to_${endDate}_movie`;
            
            log.textContent = `Processing ${username}: Initializing...`;
            progress.style.width = '0%';
            if(percentEl) percentEl.textContent = '0%';
            if(DOM.importPercentDisplay && !percentEl) DOM.importPercentDisplay.textContent = '0%';

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioDest = audioCtx.createMediaStreamDestination();
            
            // --- MUSIC HANDLING (Advanced Buffer Source) ---
            let musicSource = null;
            let musicBuffer = null;
            
            if (musicConfig && musicConfig.file) {
                log.textContent = "Decoding background music...";
                try {
                    const arrayBuffer = await musicConfig.file.arrayBuffer();
                    musicBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    
                    if (musicBuffer) {
                        musicSource = audioCtx.createBufferSource();
                        musicSource.buffer = musicBuffer;
                        
                        // FIX: Calculate total compiled video duration approx
                        // Self = 1s, Scene = 3s
                        const clipDur = APP.mode === 'scene' ? 3 : 1;
                        const totalVideoDur = items.length * clipDur;

                        // FIX: Only Loop if video is strictly longer than song
                        if (totalVideoDur > musicBuffer.duration) {
                            musicSource.loop = true;
                            // Play from start of song (or selected start?)
                            // If looping entire song:
                            musicSource.loopStart = 0;
                            musicSource.loopEnd = musicBuffer.duration;
                            musicSource.start(0, 0); 
                        } else {
                            // Perfect Fit / No Loop needed
                            musicSource.loop = false;
                            // Play specifically the segment selected
                            musicSource.start(0, musicConfig.start || 0); 
                        }
                        
                        musicSource.connect(audioDest);
                    }
                } catch (e) {
                    console.warn("Music processing failed", e);
                    log.textContent = "Music failed, skipping...";
                }
            } else if (musicConfig instanceof File) {
                // Fallback for Import Modal
                 try {
                    const arrayBuffer = await musicConfig.arrayBuffer();
                    musicBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    musicSource = audioCtx.createBufferSource();
                    musicSource.buffer = musicBuffer;
                    musicSource.loop = true; // Default loop for import mode
                    musicSource.connect(audioDest);
                    musicSource.start(0);
                 } catch (e) { console.warn("Simple music load failed", e); }
            }

            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            video.muted = false; // We control routing manually
            video.playsInline = true;
            
            // --- VIDEO AUDIO HANDLING ---
            if (!musicSource) {
                const sourceNode = audioCtx.createMediaElementSource(video);
                sourceNode.connect(audioDest);
            } else {
                video.muted = true; // Mute video if music exists
            }

            const firstFileUrl = URL.createObjectURL(items[0].blob || items[0].file);
            video.src = firstFileUrl;
            await new Promise((resolve) => {
                video.onloadedmetadata = () => resolve();
            });

            // Use passed canvas
            const w = video.videoWidth;
            const h = video.videoHeight;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            const canvasStream = canvas.captureStream(30);
            const audioTrack = audioDest.stream.getAudioTracks()[0];
            if (audioTrack) {
                canvasStream.addTrack(audioTrack);
            }

            const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? 'video/webm; codecs=vp9' 
                : 'video/webm';
                
            const recorder = new MediaRecorder(canvasStream, {
                mimeType: mimeType,
                videoBitsPerSecond: 5000000 // 5 Mbps
            });

            const chunks = [];
            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            // Start Recording
            recorder.start();
            
            // Resume Audio Context if needed
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const dateVal = item.date instanceof Date ? item.date.toISOString().split('T')[0] : item.date;
                const progressPct = Math.round(((i + 1) / items.length) * 100);
                
                log.textContent = `Processing ${username}: Clip ${i + 1}/${items.length}`;
                
                if(percentEl) percentEl.textContent = `${progressPct}%`;
                if(DOM.importPercentDisplay && !percentEl) DOM.importPercentDisplay.textContent = `${progressPct}%`;
                
                // Clean up previous source
                if (i > 0) {
                    video.pause();
                    video.removeAttribute('src'); // Detach
                    video.load(); // Reset
                    
                    // FIX: Small buffer delay to allow browser to clear memory/state
                    await new Promise(r => setTimeout(r, 50));

                    video.src = URL.createObjectURL(item.blob || item.file);
                    await new Promise(r => video.onloadedmetadata = r);
                }

                await playAndRecord(video, ctx, w, h, dateVal, addWatermark);
                
                progress.style.width = `${progressPct}%`;
            }

            // Stop Music
            if (musicSource) {
                musicSource.stop();
            }

            recorder.stop();
            log.textContent = `Processing ${username}: Finalizing...`;

            await new Promise(resolve => recorder.onstop = resolve);

            const blob = new Blob(chunks, { type: 'video/webm' });
            downloadFile(blob, `${outputName}.webm`);
            
            audioCtx.close();
            
            // Cleanup Video
            video.removeAttribute('src');
            video.load();
            
            return { blob, name: `${outputName}.webm` };
        }

        function playAndRecord(video, ctx, targetW, targetH, dateString, addWatermark) {
            return new Promise((resolve, reject) => {
                // FIX: Add safety timeout to prevent infinite freeze
                const safetyTimeout = setTimeout(() => {
                    console.warn("Video play timeout forced resolve");
                    resolve();
                }, (video.duration * 1000) + 2000); // Duration + 2s buffer

                video.currentTime = 0;
                
                const draw = () => {
                    if (video.paused || video.ended) return;
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, targetW, targetH);

                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    const scale = Math.min(targetW / vw, targetH / vh);
                    const dw = vw * scale;
                    const dh = vh * scale;
                    const dx = (targetW - dw) / 2;
                    const dy = (targetH - dh) / 2;

                    ctx.drawImage(video, dx, dy, dw, dh);
                    
                    if (addWatermark && dateString) {
                        drawWatermark(ctx, targetW, targetH, dateString, video);
                    }
                    
                    requestAnimationFrame(draw);
                };

                video.onended = () => {
                    clearTimeout(safetyTimeout);
                    resolve();
                };
                
                video.onerror = (e) => {
                    console.error("Video Error", e);
                    clearTimeout(safetyTimeout);
                    resolve(); 
                };

                video.play().then(() => {
                    draw();
                }).catch(e => {
                    console.error("Play error", e);
                    clearTimeout(safetyTimeout);
                    resolve();
                });
            });
        }

        // --- UTILS ---
        function downloadFile(blob, name) {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }

        // --- IMPORT COMPILER LOGIC (FIXED) ---
        DOM.btnImportCompile.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.remove('hidden');
            DOM.importCompileModal.classList.add('flex');
        });

        // Import Music Input Handler
        DOM.importMusicInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                DOM.importMusicText.textContent = file.name;
                DOM.importMusicText.classList.add('text-rose-400');
                DOM.importMusicCheck.setAttribute('data-lucide', 'check');
                DOM.importMusicCheck.classList.add('text-emerald-500');
                vibrate(HAPTIC.success);
                lucide.createIcons();
            }
        });

        DOM.btnCloseImportModal.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.add('hidden');
            DOM.importCompileModal.classList.remove('flex');
            
            APP.importState.files = [];
            DOM.importListContainer.innerHTML = '<p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>';
            DOM.btnStartImportCompile.disabled = true;
            DOM.importProgressArea.classList.add('hidden');
            DOM.importContentArea.classList.remove('hidden'); // Show dropzone again
            DOM.importDownloadLinks.classList.add('hidden');
            DOM.importDownloadLinks.innerHTML = '';
            DOM.importModalTitle.textContent = "Import Memories";
            
            // Reset Music Input
            DOM.importMusicInput.value = '';
            DOM.importMusicText.textContent = "Tap to select audio file";
            DOM.importMusicText.classList.remove('text-rose-400');
            DOM.importMusicCheck.setAttribute('data-lucide', 'plus');
            DOM.importMusicCheck.classList.remove('text-emerald-500');
            lucide.createIcons();
        });

        // Drag & Drop
        ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            DOM.dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault(); e.stopPropagation();
        }

        DOM.dropZone.addEventListener('dragenter', () => DOM.dropZone.classList.add('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('dragleave', () => DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('drop', handleDrop);
        
        // Click to Upload
        DOM.dropZone.addEventListener('click', () => DOM.fileInput.click());
        DOM.fileInput.addEventListener('change', (e) => processImportFiles(e.target.files));

        function handleDrop(e) {
            DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10');
            processImportFiles(e.dataTransfer.files);
        }

        function processImportFiles(fileList) {
            const files = Array.from(fileList);
            vibrate(HAPTIC.tap);

            const existingNames = new Set(APP.importState.files.map(f => f.file.name));

            let addedCount = 0;
            files.forEach(file => {
                if (!existingNames.has(file.name)) {
                    const parsed = parseFilename(file.name);
                    if (parsed) {
                        APP.importState.files.push({ file, ...parsed });
                        addedCount++;
                    }
                }
            });

            APP.importState.files.sort((a, b) => a.date - b.date);

            renderImportLists();
            
            const hasFiles = APP.importState.files.length > 0;
            DOM.btnStartImportCompile.disabled = !hasFiles;
            
            DOM.fileInput.value = ''; 
        }

        function parseFilename(filename) {
            const regexNew = /^(.*)_(self|scene)_(\d{2})-(\d{2})-(\d{4}).*$/;
            const matchNew = filename.match(regexNew);
            if (matchNew) {
                const [_, username, type, day, month, year] = matchNew;
                const date = new Date(year, month - 1, day);
                return { type, date, username, formattedDate: `${day}/${month}/${year}` };
            }

            const regexOld = /^(self|scene)_(\d{2})-(\d{2})-(\d{4}).*$/;
            const matchOld = filename.match(regexOld);
            if (matchOld) {
                const [_, type, day, month, year] = matchOld;
                const date = new Date(year, month - 1, day);
                return { type, date, username: 'Unknown', formattedDate: `${day}/${month}/${year}` };
            }
            
            return null;
        }

        function renderImportLists() {
            const container = DOM.importListContainer;
            container.innerHTML = '';

            if (APP.importState.files.length === 0) {
                container.innerHTML = '<p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>';
                return;
            }

            // Group by User
            const filesByUser = {};
            APP.importState.files.forEach(item => {
                const user = item.username;
                if (!filesByUser[user]) filesByUser[user] = { self: [], scene: [] };
                if (item.type === 'self') filesByUser[user].self.push(item);
                if (item.type === 'scene') filesByUser[user].scene.push(item);
            });

            // Iterate Users
            for (const [username, groups] of Object.entries(filesByUser)) {
                // User Wrapper
                const userSection = document.createElement('div');
                userSection.className = 'w-full bg-slate-950/50 border border-slate-800 rounded-xl p-4 flex flex-col gap-4';
                
                // User Header
                const header = document.createElement('h3');
                header.className = 'text-sm font-bold text-white flex items-center gap-2 border-b border-slate-800 pb-2';
                header.innerHTML = `<i data-lucide="user" class="w-4 h-4 text-rose-500"></i> ${username}`;
                userSection.appendChild(header);

                // Grid for Self/Scene (New Preview Flow)
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';

                // Helper to render sub-lists
                const renderSubList = (title, items) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex flex-col gap-2';
                    wrapper.innerHTML = `<h4 class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1 flex justify-between">${title} <span class="bg-slate-800 text-slate-300 px-2 rounded-md text-[10px] border border-slate-700">${items.length}</span></h4>`;
                    const listDiv = document.createElement('div');
                    listDiv.className = 'text-xs text-slate-500 space-y-1.5 max-h-32 overflow-y-auto scrollbar-thin';
                    
                    if(items.length === 0) {
                        listDiv.innerHTML = '<span class="italic opacity-50 pl-1">No clips</span>';
                    } else {
                        items.sort((a,b) => a.date - b.date).forEach(item => {
                            listDiv.innerHTML += `
                                <div class="flex justify-between items-center bg-slate-900 p-2 rounded border border-slate-800 hover:border-slate-700 transition-colors">
                                    <span class="truncate text-xs text-white font-medium w-2/3">${item.file.name}</span>
                                    <span class="text-[10px] bg-rose-900/30 text-rose-400 px-1.5 py-0.5 rounded flex-shrink-0 font-mono">${item.formattedDate}</span>
                                </div>`;
                        });
                    }
                    wrapper.appendChild(listDiv);
                    return wrapper;
                };

                grid.appendChild(renderSubList('Self Clips', groups.self));
                grid.appendChild(renderSubList('Scene Clips', groups.scene));

                userSection.appendChild(grid);
                container.appendChild(userSection);
            }
            lucide.createIcons();
        }

        DOM.btnStartImportCompile.addEventListener('click', async () => {
            if (APP.importState.isProcessing) return;
            APP.importState.isProcessing = true;
            DOM.btnStartImportCompile.disabled = true;
            vibrate(HAPTIC.action);
            
            // Get Music File
            const musicFile = DOM.importMusicInput.files[0] || null;
            // NOTE: Import modal currently doesn't support trimming UI, so pass raw file

            // TRANSITION TO PROCESSING VIEW
            DOM.importContentArea.classList.add('hidden'); // Hide list
            DOM.importProgressArea.classList.remove('hidden'); // Show progress
            DOM.importModalTitle.textContent = "Compiling Memories...";
            DOM.importDownloadLinks.classList.add('hidden');

            try {
                // Grouping Logic: User -> Mode -> Date
                const filesByUser = {};
                APP.importState.files.forEach(item => {
                    const user = item.username;
                    if (!filesByUser[user]) filesByUser[user] = { self: [], scene: [] };
                    if (item.type === 'self') filesByUser[user].self.push(item);
                    if (item.type === 'scene') filesByUser[user].scene.push(item);
                });

                const importUIContext = {
                    canvas: DOM.importPreviewCanvas,
                    progress: DOM.importProgressBar,
                    log: DOM.importStatusLog
                };

                for (const [username, groups] of Object.entries(filesByUser)) {
                    groups.self.sort((a, b) => a.date - b.date);
                    groups.scene.sort((a, b) => a.date - b.date);

                    if (groups.self.length > 0) {
                        const res = await compileClips(groups.self, username, importUIContext, false, musicFile);
                        addDownloadLink(res.blob, res.name);
                    }
                    if (groups.scene.length > 0) {
                        const res = await compileClips(groups.scene, username, importUIContext, false, musicFile);
                        addDownloadLink(res.blob, res.name);
                    }
                }

                DOM.importStatusLog.textContent = "All compilations finished!";
                DOM.importPercentDisplay.textContent = "100%";
                DOM.importProgressBar.style.width = "100%";
                vibrate(HAPTIC.success);
            } catch (err) {
                console.error(err);
                DOM.importStatusLog.textContent = "Error: " + err.message;
                vibrate(HAPTIC.warning);
            } finally {
                APP.importState.isProcessing = false;
                DOM.importDownloadLinks.classList.remove('hidden');
                DOM.btnStartImportCompile.textContent = "Compile Again";
                DOM.btnStartImportCompile.disabled = false;
            }
        });

        function addDownloadLink(blob, filename) {
            const url = URL.createObjectURL(blob);
            const btn = document.createElement('a');
            btn.href = url;
            btn.download = filename;
            btn.className = 'flex items-center justify-between bg-slate-800 hover:bg-slate-700 border border-slate-700 text-white p-4 rounded-xl transition-all group';
            btn.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="bg-rose-600/20 text-rose-500 p-2 rounded-lg">
                        <i data-lucide="video" class="w-5 h-5"></i>
                    </div>
                    <span class="text-sm font-semibold truncate max-w-[200px]">${filename}</span>
                </div>
                <i data-lucide="download" class="w-4 h-4 text-slate-400 group-hover:text-white"></i>
            `;
            DOM.importDownloadLinks.appendChild(btn);
            DOM.importDownloadLinks.classList.remove('hidden');
            lucide.createIcons();
        }

        // Boot
        initApp();
        async function initApp() {
            try {
                // Initialize Logo
                APP.logoImg = new Image();
                APP.logoImg.src = 'assets/LogoIcon-Grey.svg';
                
                // Name Check
                if (!APP.userName) {
                    const name = prompt("Enter your name:");
                    if (name && name.trim().length > 0) {
                        APP.userName = name.trim();
                        localStorage.setItem('user_name', APP.userName);
                    }
                }
                
                await initDB();
                
                updateGreeting();
                updateMonthLabel();
                updateTargetUI();
                renderCalendar();
            } catch(e) { console.error(e); }
        }

    </script>
</body>
</html>
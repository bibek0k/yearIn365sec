<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1 Second A Day</title>
    <link rel="shortcut icon" href="assets/LogoIcon.svg" type="image/x-icon">
    
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --primary: #e11d48; /* Rose-600 */
            --bg: #0f172a; /* Slate-900 */
            --surface: #1e293b; /* Slate-800 */
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            overscroll-behavior-y: none;
        }

        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .camera-container {
            position: relative;
            width: 100%;
            padding-top: 133.33%; /* 3:4 Aspect Ratio (480x640) */
            background: #000;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.1s ease-in-out;
        }

        /* Screen Flash: Warm White Shadow covering everything OUTSIDE the camera container */
        .camera-container.flash-active {
            box-shadow: 0 0 0 200vmax rgba(255, 248, 235, 0.95); /* Warm White */
            z-index: 100;
        }

        .camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
        }

        /* CSS Mirroring for Preview */
        .camera-feed.mirrored {
            transform: scaleX(-1);
        }
        
        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }
        
        /* Responsive Grid for Tablet/Desktop */
        @media (min-width: 768px) {
            .calendar-grid {
                gap: 0.75rem;
            }
        }

        .day-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border-radius: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: all 0.2s;
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
        }

        .day-cell:hover {
            border-color: rgba(255,255,255,0.1);
        }

        .day-cell.filled {
            background: var(--primary);
            color: white;
            box-shadow: 0 0 10px rgba(225, 29, 72, 0.4);
        }
        
        .day-cell.target-active {
            border-color: #3b82f6; /* Blue border for target */
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
        }

        .safe-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Toggle Switch */
        .mode-toggle {
            background: var(--surface);
            border-radius: 9999px;
            padding: 4px;
            display: flex;
            position: relative;
        }
        .mode-btn {
            z-index: 10;
            flex: 1;
            text-align: center;
            padding: 6px 12px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 9999px;
            transition: color 0.2s;
            cursor: pointer;
        }
        .mode-bg {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc(50% - 4px);
            background: var(--primary);
            border-radius: 9999px;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Shake Animation for Invalid Input */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-4px); }
            80% { transform: translateX(4px); }
        }
        .animate-shake {
            animation: shake 0.4s ease-in-out;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center safe-pb">

    <!-- Header & Mode Switch -->
    <header class="w-full max-w-5xl p-6 pb-2 flex flex-col gap-4 z-10">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold tracking-tight">My Year</h1>
                <p class="text-slate-400 text-sm" id="dateDisplay">Loading...</p>
            </div>
            <!-- Mode Toggle -->
            <div class="mode-toggle w-40">
                <div id="modeBg" class="mode-bg"></div>
                <div id="modeSelf" class="mode-btn text-white">Self</div>
                <div id="modeScene" class="mode-btn text-slate-400">Scene</div>
            </div>
        </div>
        
        <!-- Search Bar Wrapper -->
        <div class="w-full">
            <div id="searchContainer" class="flex gap-2 w-full transition-colors">
                <input type="text" id="dateSearchInput" placeholder="Jump to DD-MM-YYYY or Day-X" class="bg-slate-800 text-white px-4 py-2 rounded-lg flex-1 text-sm border border-slate-700 focus:outline-none focus:border-rose-600 placeholder-slate-500 transition-all">
                <button id="btnSearch" class="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg transition-colors"><i data-lucide="search" class="w-4 h-4"></i></button>
            </div>
            <!-- Error Label -->
            <p id="searchError" class="text-red-500 text-xs mt-1.5 pl-1 hidden font-medium flex items-center gap-1 opacity-0 transition-opacity duration-200">
                <i data-lucide="alert-circle" class="w-3 h-3"></i> <span>Error message</span>
            </p>
        </div>

        <!-- Recording Target Indicator -->
        <div id="targetIndicator" class="hidden w-full bg-blue-500/10 border border-blue-500/20 rounded-lg p-2 text-center">
            <p class="text-blue-400 text-xs font-medium">Recording for: <span id="targetDateDisplay" class="font-bold text-blue-300"></span></p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="w-full max-w-5xl flex-1 px-4 flex flex-col md:flex-row gap-6 md:gap-8 items-start justify-center">

        <!-- Recorder Section Wrapper -->
        <div class="w-full md:w-[26rem] lg:w-[28rem] flex-shrink-0 mx-auto md:mx-0 md:sticky md:top-6">
            <div id="recorderSection" class="relative">
                <div id="cameraContainer" class="camera-container">
                    <video id="cameraPreview" autoplay playsinline muted class="camera-feed hidden"></video>
                    <video id="playbackPreview" playsinline loop class="camera-feed hidden"></video>
                    
                    <!-- Start Overlay -->
                    <div id="startOverlay" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/50 backdrop-blur-sm z-10 transition-opacity">
                        <button id="btnInitCamera" class="bg-rose-600 hover:bg-rose-700 text-white rounded-full p-6 shadow-lg transform transition active:scale-95">
                            <i data-lucide="camera" class="w-8 h-8"></i>
                        </button>
                        <p class="mt-4 text-sm font-medium text-white/90">Tap to Start Camera</p>
                    </div>

                    <!-- Done Overlay -->
                    <div id="doneOverlay" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-slate-900/90 z-20">
                        <div class="bg-green-500/20 text-green-400 p-4 rounded-full mb-4">
                            <i data-lucide="check" class="w-8 h-8"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white">Captured!</h3>
                        <div class="flex gap-4 mt-6">
                             <button id="btnViewClip" class="text-sm bg-slate-700 text-white px-4 py-2 rounded-lg">View</button>
                        </div>
                    </div>

                    <!-- Camera Tools (Switch & Flash) -->
                    <div class="absolute top-4 right-4 z-30 flex flex-col gap-2">
                        <button id="btnSwitchCam" class="hidden bg-slate-800/80 text-white p-2 rounded-full backdrop-blur-sm">
                            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                        </button>
                        <button id="btnFlash" class="hidden bg-slate-800/80 text-slate-400 p-2 rounded-full backdrop-blur-sm">
                            <i id="iconFlash" data-lucide="zap-off" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>

                <!-- Controls -->
                <div class="mt-6 flex items-center justify-center relative h-24">
                    <div id="recordControls" class="relative hidden">
                        <svg class="progress-ring w-20 h-20" viewBox="0 0 100 100">
                            <circle class="text-slate-700" stroke="currentColor" stroke-width="4" fill="transparent" r="45" cx="50" cy="50"/>
                            <circle id="progressCircle" class="progress-ring__circle text-rose-500" stroke="currentColor" stroke-width="4" fill="transparent" r="45" cx="50" cy="50" stroke-dasharray="282.74" stroke-dashoffset="282.74"/>
                        </svg>
                        
                        <button id="btnRecord" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-rose-600 rounded-full border-4 border-slate-900 shadow-xl active:scale-90 transition-transform flex items-center justify-center">
                            <div id="recIcon" class="w-6 h-6 bg-white rounded-sm"></div>
                        </button>
                    </div>
                    <p id="statusText" class="absolute -bottom-2 text-xs text-slate-500 font-mono">Ready</p>
                </div>
            </div>
        </div>

        <!-- Hidden Canvas for recording processing -->
        <canvas id="processingCanvas" class="hidden"></canvas>

        <!-- Month Grid View -->
        <div class="w-full md:flex-1 bg-slate-800 rounded-xl p-4 flex flex-col gap-4">
            <!-- Month Navigation -->
            <div class="flex justify-between items-center">
                <button id="btnPrevMonth" class="p-2 hover:bg-slate-700 rounded-full text-slate-400"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                <h2 id="monthLabel" class="text-sm font-bold text-white uppercase tracking-widest">Month</h2>
                <button id="btnNextMonth" class="p-2 hover:bg-slate-700 rounded-full text-slate-400"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
            </div>

            <!-- Grid -->
            <div id="calendarGrid" class="calendar-grid">
                <!-- Days injected by JS -->
            </div>

            <!-- Tools -->
            <div class="flex gap-2 justify-center border-t border-slate-700 pt-4">
                <button id="btnCompile" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-md flex items-center gap-2 transition-colors">
                    <i data-lucide="film" class="w-3 h-3"></i> Compile Month
                </button>
                <!-- REPLACED: Export All with Import & Compile -->
                <button id="btnImportCompile" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-md flex items-center gap-2 transition-colors">
                    <i data-lucide="upload" class="w-3 h-3"></i> Import & Compile
                </button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="w-full text-center py-6 text-slate-500 text-xs font-medium">
        <p>All Rights Reserved â€¢ Made with love & patience of Bibek</p>
    </footer>

    <!-- Clip Viewer / Delete Modal -->
    <div id="clipModal" class="fixed inset-0 bg-slate-950/95 z-40 hidden flex-col items-center justify-center p-4 sm:p-6">
        <div class="relative w-full max-w-md md:max-w-lg max-h-[90vh] overflow-y-auto bg-slate-900 rounded-xl overflow-hidden shadow-2xl border border-slate-800 flex flex-col">
            <div class="absolute top-4 left-0 w-full flex justify-center z-10 pointer-events-none">
                <span id="modalDateDisplay" class="bg-black/40 backdrop-blur-md text-white/90 px-4 py-1.5 rounded-full text-sm font-medium shadow-lg border border-white/10"></span>
            </div>
            <video id="modalVideo" controls playsinline webkit-playsinline class="w-full aspect-[3/4] bg-black block"></video>
            <div class="p-4 flex justify-between items-center bg-slate-900 sticky bottom-0 z-20 border-t border-slate-800">
                <button id="btnCloseClip" class="text-slate-400 hover:text-white text-sm transition-colors">Close</button>
                <div class="flex gap-4">
                    <!-- NEW: Dedicated Download Button -->
                    <button id="btnDownloadClip" class="text-green-500 hover:text-green-400 font-medium flex items-center gap-2 text-sm transition-colors">
                        <i data-lucide="download" class="w-4 h-4"></i> Download
                    </button>
                    <button id="btnDeleteClip" class="text-red-500 hover:text-red-400 font-medium flex items-center gap-2 text-sm transition-colors rounded px-2 py-1">
                        <i data-lucide="trash-2" class="w-4 h-4"></i> Delete
                    </button>
                    <button id="btnReplaceClip" class="text-blue-500 hover:text-blue-400 font-medium flex items-center gap-2 text-sm transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i> Replace
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Compile Modal (Internal Clips) -->
    <div id="compileModal" class="fixed inset-0 bg-slate-950/90 z-50 hidden flex-col items-center justify-center p-6 text-center">
        <div class="max-w-sm w-full bg-slate-900 border border-slate-800 p-6 rounded-2xl shadow-2xl">
            <h3 class="text-xl font-bold mb-4">Compiling Movie</h3>
            <div class="relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 border border-slate-800 shadow-inner">
                <canvas id="compileCanvas" class="w-full h-full object-contain"></canvas>
            </div>
            <div class="w-full bg-slate-800 h-2 rounded-full overflow-hidden mb-2">
                <div id="compileProgress" class="bg-rose-600 h-full w-0 transition-all duration-300"></div>
            </div>
            <p id="compileLog" class="text-xs text-slate-500 font-mono mb-6">Initializing...</p>
            <button id="btnCloseModal" class="hidden w-full bg-slate-800 text-white py-3 rounded-lg hover:bg-slate-700 transition-colors">Close</button>
        </div>
    </div>

    <!-- NEW: Import & Compile Modal -->
    <div id="importCompileModal" class="fixed inset-0 bg-slate-950/90 z-50 hidden flex-col items-center justify-center p-4 sm:p-6 overflow-y-auto">
        <div class="relative w-full max-w-2xl bg-slate-900 border border-slate-800 p-6 rounded-2xl shadow-2xl flex flex-col gap-4 max-h-full">
            <h3 class="text-xl font-bold text-center">Import & Compile</h3>
            
            <!-- Drop Zone -->
            <label id="dropZone" class="border-2 border-dashed border-slate-700 hover:border-rose-600 hover:bg-rose-600/5 bg-slate-800/50 rounded-xl p-8 text-center transition-all cursor-pointer flex flex-col items-center gap-2">
                <input type="file" id="fileInput" multiple accept="video/*" class="hidden">
                <i data-lucide="upload-cloud" class="w-10 h-10 text-slate-500"></i>
                <strong class="text-white">Click or Drag Videos Here</strong>
                <p class="text-xs text-slate-500">Format: self_DD-MM-YYYY.* or scene_DD-MM-YYYY.*</p>
            </label>

            <!-- File Lists -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div class="bg-slate-950 border border-slate-800 rounded-lg p-3">
                    <h4 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 flex justify-between">
                        Self Clips <span id="selfCount" class="bg-slate-800 text-white px-2 rounded-full text-[10px] py-0.5">0</span>
                    </h4>
                    <div id="selfList" class="text-xs text-slate-500 space-y-1 max-h-32 overflow-y-auto">No files yet.</div>
                </div>
                <div class="bg-slate-950 border border-slate-800 rounded-lg p-3">
                    <h4 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 flex justify-between">
                        Scene Clips <span id="sceneCount" class="bg-slate-800 text-white px-2 rounded-full text-[10px] py-0.5">0</span>
                    </h4>
                    <div id="sceneList" class="text-xs text-slate-500 space-y-1 max-h-32 overflow-y-auto">No files yet.</div>
                </div>
            </div>

            <!-- Progress & Preview Area (Hidden initially) -->
            <div id="importProgressArea" class="hidden flex flex-col gap-3 border-t border-slate-800 pt-4">
                <div class="relative w-full aspect-video bg-black rounded-lg overflow-hidden border border-slate-800 shadow-inner">
                    <canvas id="importPreviewCanvas" class="w-full h-full object-contain"></canvas>
                </div>
                <div class="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                    <div id="importProgressBar" class="bg-rose-600 h-full w-0 transition-all duration-300"></div>
                </div>
                <p id="importStatusLog" class="text-xs text-slate-500 font-mono text-center">Ready...</p>
            </div>

            <!-- Actions -->
            <div class="flex flex-col gap-2 mt-2">
                <button id="btnStartImportCompile" class="w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Compile Files
                </button>
                <div id="importDownloadLinks" class="flex flex-col gap-2 hidden">
                    <!-- Download buttons injected here -->
                </div>
                <button id="btnCloseImportModal" class="w-full text-slate-400 hover:text-white text-sm py-2">Close</button>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- STATE & CONFIG ---
        const APP = {
            dbName: 'OneSecondADayDB',
            storeName: 'clips',
            version: 1,
            db: null,
            // FIX: Use local date to ensure search/calendar alignment (prevents UTC mismatch)
            today: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            mediaRecorder: null,
            recordedChunks: [],
            cameraStream: null,
            
            // New State for V2
            mode: 'self', // 'self' or 'scene'
            viewDate: new Date(), // Tracks month view
            // FIX: Initialize targetDate to local today as well
            targetDate: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(), // Default recording target is today
            sceneCamFacing: 'environment', // default rear for scene
            
            // Rendering loop
            animationId: null,

            // Flash State
            flashEnabled: false,
            hasTorch: false,
            trackRef: null, // Reference to the video track for torch
            
            // Import Compiler State
            importState: {
                self: [],
                scene: [],
                isProcessing: false
            },
            
            // Assets
            logoImg: null
        };

        const DOM = {
            // Displays
            dateDisplay: document.getElementById('dateDisplay'),
            targetDateDisplay: document.getElementById('targetDateDisplay'),
            targetIndicator: document.getElementById('targetIndicator'),
            monthLabel: document.getElementById('monthLabel'),
            statusText: document.getElementById('statusText'),
            
            // Search
            dateSearchInput: document.getElementById('dateSearchInput'),
            btnSearch: document.getElementById('btnSearch'),
            searchContainer: document.getElementById('searchContainer'),
            searchError: document.getElementById('searchError'),

            // Camera
            cameraContainer: document.getElementById('cameraContainer'),
            cameraPreview: document.getElementById('cameraPreview'),
            playbackPreview: document.getElementById('playbackPreview'),
            processingCanvas: document.getElementById('processingCanvas'), 
            
            // Mode Switcher
            modeSelf: document.getElementById('modeSelf'),
            modeScene: document.getElementById('modeScene'),
            modeBg: document.getElementById('modeBg'),
            
            // Overlays & Buttons
            startOverlay: document.getElementById('startOverlay'),
            doneOverlay: document.getElementById('doneOverlay'),
            btnInit: document.getElementById('btnInitCamera'),
            btnRecord: document.getElementById('btnRecord'),
            btnRetake: document.getElementById('btnRetake'),
            btnSwitchCam: document.getElementById('btnSwitchCam'),
            btnViewClip: document.getElementById('btnViewClip'),
            btnFlash: document.getElementById('btnFlash'),
            iconFlash: document.getElementById('iconFlash'),

            // Grid & Nav
            calendarGrid: document.getElementById('calendarGrid'),
            btnPrevMonth: document.getElementById('btnPrevMonth'),
            btnNextMonth: document.getElementById('btnNextMonth'),
            
            // Modals
            clipModal: document.getElementById('clipModal'),
            modalVideo: document.getElementById('modalVideo'),
            modalDateDisplay: document.getElementById('modalDateDisplay'),
            btnCloseClip: document.getElementById('btnCloseClip'),
            btnDeleteClip: document.getElementById('btnDeleteClip'),
            btnReplaceClip: document.getElementById('btnReplaceClip'),
            btnDownloadClip: document.getElementById('btnDownloadClip'), // NEW
            
            // Compile
            btnCompile: document.getElementById('btnCompile'),
            compileModal: document.getElementById('compileModal'),
            compileProgress: document.getElementById('compileProgress'),
            compileLog: document.getElementById('compileLog'),
            btnCloseModal: document.getElementById('btnCloseModal'),
            compileCanvas: document.getElementById('compileCanvas'),
            
            // Import Compiler
            btnImportCompile: document.getElementById('btnImportCompile'),
            importCompileModal: document.getElementById('importCompileModal'),
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            selfList: document.getElementById('selfList'),
            sceneList: document.getElementById('sceneList'),
            selfCount: document.getElementById('selfCount'),
            sceneCount: document.getElementById('sceneCount'),
            btnStartImportCompile: document.getElementById('btnStartImportCompile'),
            importProgressArea: document.getElementById('importProgressArea'),
            importPreviewCanvas: document.getElementById('importPreviewCanvas'),
            importProgressBar: document.getElementById('importProgressBar'),
            importStatusLog: document.getElementById('importStatusLog'),
            importDownloadLinks: document.getElementById('importDownloadLinks'),
            btnCloseImportModal: document.getElementById('btnCloseImportModal'),

            // Icons & Rings
            recordControls: document.getElementById('recordControls'),
            progressCircle: document.getElementById('progressCircle'),
            recIcon: document.getElementById('recIcon')
        };

        // --- INIT ---
        DOM.dateDisplay.textContent = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

        // Helper to format dates as DD-MM-YYYY for display
        function formatDateDisplay(isoDateString) {
            if (!isoDateString) return '';
            const [y, m, d] = isoDateString.split('-');
            return `${d}-${m}-${y}`;
        }

        // --- HAPTICS UTILITY (ENHANCED & BOOSTED) ---
        // Tuned for perceptibility on mobile devices while remaining intentional
        const HAPTIC = {
            tap: 35,             // Standard UI tap (was 15)
            action: 75,          // Primary button actions (was 25)
            success: 100,        // Success confirmation (was 35)
            warning: 200,        // Error/Warning buzz (was 50)
            destructive: [100, 50, 150] // Destructive action (stronger double pulse)
        };

        function vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }
        
        // --- DATABASE ---
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(APP.dbName, APP.version);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(APP.storeName)) {
                        db.createObjectStore(APP.storeName, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => { APP.db = e.target.result; resolve(APP.db); };
                request.onerror = (e) => reject(e);
            });
        }

        // Key Format: "mode_YYYY-MM-DD" e.g., "self_2024-03-21"
        function getKey(date, mode) {
            return `${mode}_${date}`;
        }

        async function saveClip(date, mode, blob) {
            const id = getKey(date, mode);
            return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.put({ id: id, date: date, mode: mode, blob: blob, timestamp: Date.now() });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getClip(date, mode) {
            if (!APP.db) return null;
            const id = getKey(date, mode);
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        }
        
        async function deleteClip(date, mode) {
            const id = getKey(date, mode);
             return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getAllClips(mode) {
             if (!APP.db) return [];
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).getAll();
                req.onsuccess = () => {
                    const all = req.result || [];
                    resolve(all.filter(c => c.mode === mode));
                };
            });
        }

        // --- SEARCH LOGIC (DAY-X & HAPTIC ENABLED) ---
        DOM.btnSearch.addEventListener('click', () => {
            vibrate(HAPTIC.tap); 
            handleSearch();
        });
        DOM.dateSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });

        // Clear error on input
        DOM.dateSearchInput.addEventListener('input', () => {
             DOM.searchError.classList.add('hidden');
             DOM.searchError.classList.add('opacity-0');
             DOM.dateSearchInput.classList.remove('border-red-500');
             DOM.dateSearchInput.classList.add('border-slate-700');
        });

        function triggerSearchError(msg) {
            // Update Text
            DOM.searchError.querySelector('span').textContent = msg;
            
            // Show Label
            DOM.searchError.classList.remove('hidden');
            // Small timeout to allow transition
            setTimeout(() => DOM.searchError.classList.remove('opacity-0'), 10);
            
            // Style Input
            DOM.dateSearchInput.classList.remove('border-slate-700');
            DOM.dateSearchInput.classList.add('border-red-500');

            // Haptic Feedback for Error
            vibrate(HAPTIC.warning);

            // Visual Shake
            DOM.searchContainer.classList.add('animate-shake');
            setTimeout(() => DOM.searchContainer.classList.remove('animate-shake'), 400);
        }

        async function handleSearch() {
            const input = DOM.dateSearchInput.value.trim();
            
            // Regex definitions
            const dateRegex = /^(\d{2})-(\d{2})-(\d{4})$/;
            const dayRegex = /^Day-(\d+)$/i;

            let isoDate;
            let targetYear, targetMonth;

            if (dayRegex.test(input)) {
                // Handle Day-X
                const match = input.match(dayRegex);
                const dayNum = parseInt(match[1], 10);
                const currentYear = new Date().getFullYear();
                
                if (dayNum < 1 || dayNum > 366) {
                    triggerSearchError("Invalid Day Number");
                    return;
                }

                // Calculate date from day number
                const calculatedDate = new Date(currentYear, 0, dayNum); // Jan is 0
                
                // Validate year didn't rollover (e.g. Day-366 in non-leap year)
                if (calculatedDate.getFullYear() !== currentYear) {
                     triggerSearchError(`Day-${dayNum} does not exist in ${currentYear}`);
                     return;
                }

                const y = calculatedDate.getFullYear();
                const m = String(calculatedDate.getMonth() + 1).padStart(2, '0');
                const d = String(calculatedDate.getDate()).padStart(2, '0');
                isoDate = `${y}-${m}-${d}`;
                
                targetYear = y;
                targetMonth = calculatedDate.getMonth();

            } else if (dateRegex.test(input)) {
                // Handle DD-MM-YYYY
                const match = input.match(dateRegex);
                const [_, d, m, y] = match;
                isoDate = `${y}-${m}-${d}`;
                
                const testDate = new Date(isoDate);
                if (isNaN(testDate.getTime()) || testDate.getMonth() + 1 !== parseInt(m)) {
                    triggerSearchError("Date does not exist");
                    return;
                }
                
                targetYear = Number(y);
                targetMonth = Number(m) - 1;

            } else {
                triggerSearchError("Format: DD-MM-YYYY or Day-X");
                return;
            }

            // Check for clip existence first
            const clip = await getClip(isoDate, APP.mode);
            
            // Validate that clip exists AND has actual data
            if (clip && clip.blob && clip.blob.size > 0) {
                // Success Haptic
                vibrate(HAPTIC.success);

                // Clear errors, navigate, and show clip
                DOM.searchError.classList.add('hidden');
                DOM.searchError.classList.add('opacity-0');
                DOM.dateSearchInput.classList.remove('border-red-500');
                DOM.dateSearchInput.classList.add('border-slate-700');

                APP.viewDate = new Date(targetYear, targetMonth, 1);
                updateMonthLabel();
                
                await renderCalendar();
                openClipModal(isoDate); 
            } else {
                // Failure: No valid recording found
                triggerSearchError("No recording found.");
            }
        }

        // --- VIEW & NAVIGATION LOGIC ---

        function updateMonthLabel() {
            DOM.monthLabel.textContent = APP.viewDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        async function renderCalendar() {
            const clips = await getAllClips(APP.mode);
            // FIX: Only treat valid video files as clips for the calendar badges
            const validClips = clips.filter(c => c.blob && c.blob.size > 0);
            const clipMap = new Map(validClips.map(c => [c.date, c]));
            
            DOM.calendarGrid.innerHTML = '';
            
            const year = APP.viewDate.getFullYear();
            const month = APP.viewDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                const dateObj = new Date(year, month, d);
                const dayOfYear = getDayOfYear(dateObj);
                
                const el = document.createElement('div');
                el.className = 'day-cell';
                el.title = formatDateDisplay(dateStr);
                
                const clip = clipMap.get(dateStr);
                const isTarget = dateStr === APP.targetDate;

                el.innerHTML = `<span class="text-xs font-bold">Day</span><span class="text-lg leading-none">${dayOfYear}</span>`;

                if (clip) {
                    el.classList.add('filled');
                    // Pass the already-loaded clip object directly to avoid async fetch failure
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        openClipModal(clip);
                    };
                } else {
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        setTargetDate(dateStr);
                    };
                }

                if (isTarget) {
                    el.classList.add('target-active');
                }

                DOM.calendarGrid.appendChild(el);
            }
        }

        DOM.btnPrevMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() - 1);
            updateMonthLabel();
            renderCalendar();
        });

        DOM.btnNextMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() + 1);
            updateMonthLabel();
            renderCalendar();
        });

        // --- MODE SWITCHING ---

        function setMode(mode) {
            APP.mode = mode;
            APP.targetDate = APP.today;
            updateTargetUI();
            
            if (mode === 'self') {
                DOM.modeSelf.classList.replace('text-slate-400', 'text-white');
                DOM.modeScene.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(0)';
                DOM.btnSwitchCam.classList.add('hidden');
                DOM.cameraPreview.classList.add('mirrored'); // CSS Mirror for preview
            } else {
                DOM.modeScene.classList.replace('text-slate-400', 'text-white');
                DOM.modeSelf.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(100%)';
                DOM.cameraPreview.classList.remove('mirrored');
                if(APP.cameraStream) DOM.btnSwitchCam.classList.remove('hidden');
            }
            
            renderCalendar();
            resetRecorderUI();
            if (APP.cameraStream) startCamera(); 
        }

        DOM.modeSelf.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('self'); });
        DOM.modeScene.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('scene'); });

        // --- REPLACE / TARGET LOGIC ---

        function setTargetDate(date) {
            APP.targetDate = date;
            updateTargetUI();
            resetRecorderUI();
            renderCalendar();
        }
        
        function updateTargetUI() {
            DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
            if (APP.targetDate !== APP.today) {
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;
            } else {
                DOM.targetIndicator.classList.add('hidden');
                DOM.statusText.textContent = "Ready";
            }
            checkTargetStatus();
        }
        
        async function checkTargetStatus() {
            const existing = await getClip(APP.targetDate, APP.mode);
            if (existing && existing.blob && existing.blob.size > 0) {
                showDoneState(existing.blob);
            } else {
                showReadyState();
            }
        }

        async function openClipModal(clipOrDate) {
            let clip;
            let date;

            // Robust handling: If passed a string (legacy), fetch it. If object, use it directly.
            if (typeof clipOrDate === 'string') {
                date = clipOrDate;
                clip = await getClip(date, APP.mode);
            } else {
                clip = clipOrDate;
                date = clip.date;
            }

            if (!clip || !clip.blob || clip.blob.size === 0) {
                triggerSearchError("Error: Valid recording not found");
                return;
            }
            
            try {
                // Determine correct filename: self_DD-MM-YYYY or scene_DD-MM-YYYY
                const safeMode = clip.mode || APP.mode;
                const fileName = `${safeMode}_${formatDateDisplay(date)}.webm`;
                
                // Wrap blob in File object for browser compatibility, but primarily rely on the button below
                const file = new File([clip.blob], fileName, { type: clip.blob.type });
                
                DOM.modalVideo.src = URL.createObjectURL(file);
                DOM.modalDateDisplay.textContent = formatDateDisplay(date);
                DOM.clipModal.classList.remove('hidden');
                DOM.clipModal.classList.add('flex');

                // NEW: Dedicated Download Button Logic
                DOM.btnDownloadClip.onclick = () => {
                    vibrate(HAPTIC.tap);
                    downloadFile(clip.blob, fileName);
                };

            } catch (e) {
                console.error("Error displaying video", e);
                DOM.statusText.textContent = "Error: Video unavailable";
                return;
            }
            
            // DELETE ACTION (UX IMPROVED: Two-Step Confirm + Haptic)
            DOM.btnDeleteClip.onclick = async () => {
                // State: 'confirm' means user clicked once
                if (DOM.btnDeleteClip.dataset.state === 'confirm') {
                    // ACTION: Delete
                    
                    // Trigger Destructive Haptic on deletion
                    vibrate(HAPTIC.destructive);
                    
                    await deleteClip(date, APP.mode);
                    DOM.clipModal.classList.add('hidden');
                    DOM.clipModal.classList.remove('flex');
                    await renderCalendar(); // Refresh grid
                    setTargetDate(APP.today); // Reset target to today

                    // Reset button state
                    DOM.btnDeleteClip.dataset.state = '';
                    DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i> Delete';
                    lucide.createIcons();
                } else {
                    // ACTION: Ask for confirmation (First Click)
                    vibrate(HAPTIC.warning); // Attention haptic
                    DOM.btnDeleteClip.dataset.state = 'confirm';
                    const originalContent = DOM.btnDeleteClip.innerHTML;
                    
                    DOM.btnDeleteClip.innerHTML = '<span class="text-red-400 font-bold">Confirm?</span>';
                    
                    // Auto-reset after 3 seconds if not confirmed
                    setTimeout(() => {
                        if (DOM.btnDeleteClip.dataset.state === 'confirm') {
                            DOM.btnDeleteClip.dataset.state = '';
                            DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i> Delete';
                            lucide.createIcons();
                        }
                    }, 3000);
                }
            };

            // REPLACE ACTION
            DOM.btnReplaceClip.onclick = () => {
                vibrate(HAPTIC.tap); 
                // 1. Close modal
                DOM.clipModal.classList.add('hidden');
                DOM.clipModal.classList.remove('flex');
                DOM.modalVideo.pause();

                // 2. Set target date to this clip's date
                APP.targetDate = date;
                
                // 3. Update UI text manually
                DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;

                // 4. Force "Ready" state (Recording Mode) immediately
                // We bypass checkTargetStatus() so it doesn't show the existing video preview
                showReadyState();
            };
        }
        
        DOM.btnCloseClip.addEventListener('click', () => {
            // Reset delete state on close
            DOM.btnDeleteClip.dataset.state = '';
            DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i> Delete';
            lucide.createIcons();
            
            vibrate(HAPTIC.tap);

            DOM.clipModal.classList.add('hidden');
            DOM.clipModal.classList.remove('flex');
            DOM.modalVideo.pause();
        });

        // --- CAMERA & FLASH LOGIC ---
        
        DOM.btnInit.addEventListener('click', () => { 
            vibrate(HAPTIC.action); 
            startCamera(); 
        });
        
        DOM.btnSwitchCam.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.sceneCamFacing = APP.sceneCamFacing === 'environment' ? 'user' : 'environment';
            startCamera();
        });

        DOM.btnFlash.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            toggleFlashState();
        });

        function toggleFlashState() {
            APP.flashEnabled = !APP.flashEnabled;
            updateFlashUI();
        }

        function updateFlashUI() {
            if (APP.flashEnabled) {
                DOM.btnFlash.classList.replace('text-slate-400', 'text-yellow-400');
                DOM.iconFlash.setAttribute('data-lucide', 'zap');
            } else {
                DOM.btnFlash.classList.replace('text-yellow-400', 'text-slate-400');
                DOM.iconFlash.setAttribute('data-lucide', 'zap-off');
            }
            lucide.createIcons();
        }

        async function applyTorch(state) {
            if (APP.hasTorch && APP.trackRef) {
                try {
                    await APP.trackRef.applyConstraints({ advanced: [{ torch: state }] });
                } catch (e) {
                    console.warn("Torch failed", e);
                }
            }
        }

        async function startCamera() {
             if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                DOM.statusText.textContent = "Error: HTTPS Required";
                return;
            }

            // Cleanup previous
            if (APP.cameraStream) {
                APP.cameraStream.getTracks().forEach(t => t.stop());
                if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.statusText.textContent = "Starting camera...";
            
            // REMOVED forced resolution/aspectRatio constraints for mobile stability
            let constraints = { 
                audio: true, 
                video: {
                    facingMode: APP.mode === 'self' ? 'user' : { ideal: APP.sceneCamFacing }
                } 
            };

            try {
                APP.cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                DOM.cameraPreview.srcObject = APP.cameraStream;
                await DOM.cameraPreview.play();
                DOM.cameraPreview.classList.remove('hidden');
                DOM.playbackPreview.classList.add('hidden');
                DOM.startOverlay.classList.add('opacity-0', 'pointer-events-none');
                DOM.recordControls.classList.remove('hidden');
                DOM.statusText.textContent = `Ready (${APP.mode})`;
                
                // Mirroring Check
                if (APP.mode === 'self') {
                    DOM.cameraPreview.classList.add('mirrored');
                } else {
                    DOM.cameraPreview.classList.remove('mirrored');
                }

                // Show camera controls
                DOM.btnFlash.classList.remove('hidden');
                if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');

                // Check Torch Capabilities
                const track = APP.cameraStream.getVideoTracks()[0];
                APP.trackRef = track;
                const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                APP.hasTorch = !!capabilities.torch;
                
                // START CANVAS LOOP
                updateCanvasLoop();

            } catch (err) {
                console.error(err);
                DOM.statusText.textContent = "Error: " + err.name;
            }
        }

        function updateCanvasLoop() {
            const ctx = DOM.processingCanvas.getContext('2d');
            const video = DOM.cameraPreview;
            const canvas = DOM.processingCanvas;

            // Helper for rounded rect paths
            const roundRect = (x, y, w, h, r) => {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            };

            function draw() {
                if (video.readyState >= 2) { 
                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    
                    if (canvas.width !== vw || canvas.height !== vh) {
                        canvas.width = vw;
                        canvas.height = vh;
                    }

                    const cw = canvas.width;
                    const ch = canvas.height;

                    // 1. Draw Base Video (Mirrored if 'self')
                    ctx.save();
                    if (APP.mode === 'self') {
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.filter = 'none';
                    ctx.drawImage(video, 0, 0, cw, ch);
                    ctx.restore();

                    // --- WATERMARK LOGIC (REFINED v3) ---
                    // Configured for "Tight capsule, specific grey" aesthetics
                    const margin = cw * 0.04;
                    const boxHeight = cw * 0.065;
                    const boxRadius = boxHeight / 2;   // Full capsule radius
                    const fontSize = boxHeight * 0.45;
                    const paddingX = boxHeight * 0.5;  // Reduced padding to hug text tightly
                    
                    // Parse Date
                    const [y, m, d] = APP.targetDate.split('-');
                    const dateObj = new Date(Number(y), Number(m)-1, Number(d));
                    const dateText = dateObj.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }).toUpperCase();
                    const dayNum = getDayOfYear(dateObj);
                    const dayText = `DAY ${dayNum}`;

                    // Measure content
                    ctx.font = `700 ${fontSize}px "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                    const logoSize = boxHeight * 0.6;
                    const gap = boxHeight * 0.4;
                    
                    // Left Box Geometry (Logo + Date)
                    const leftTextWidth = ctx.measureText(dateText).width;
                    const leftBoxWidth = paddingX + logoSize + gap + leftTextWidth + paddingX;
                    const leftBoxX = margin;
                    const leftBoxY = ch - margin - boxHeight;

                    // Right Box Geometry (Day #)
                    const rightTextWidth = ctx.measureText(dayText).width;
                    const rightBoxWidth = paddingX + rightTextWidth + paddingX;
                    const rightBoxX = cw - margin - rightBoxWidth;
                    const rightBoxY = ch - margin - boxHeight;

                    // 2. Draw Blurred Backgrounds (Frosted Glass)
                    ctx.save();
                    roundRect(leftBoxX, leftBoxY, leftBoxWidth, boxHeight, boxRadius);
                    roundRect(rightBoxX, rightBoxY, rightBoxWidth, boxHeight, boxRadius);
                    ctx.clip();
                    
                    if (APP.mode === 'self') {
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.filter = 'blur(12px)';
                    ctx.drawImage(video, 0, 0, cw, ch);
                    ctx.restore();

                    // 3. Draw Overlays & Text
                    const overlayColor = 'rgba(15, 23, 42, 0.55)'; 
                    const textColor = '#cbcbcb'; // Specific grey color requested

                    // Backgrounds
                    ctx.fillStyle = overlayColor;
                    ctx.beginPath(); roundRect(leftBoxX, leftBoxY, leftBoxWidth, boxHeight, boxRadius); ctx.fill();
                    ctx.beginPath(); roundRect(rightBoxX, rightBoxY, rightBoxWidth, boxHeight, boxRadius); ctx.fill();

                    // Left Box Content
                    const iconY = leftBoxY + (boxHeight - logoSize) / 2;
                    const iconX = leftBoxX + paddingX;
                    
                    if (APP.logoImg && APP.logoImg.complete && APP.logoImg.naturalHeight !== 0) {
                        ctx.drawImage(APP.logoImg, iconX, iconY, logoSize, logoSize);
                    }
                    
                    ctx.fillStyle = textColor;
                    ctx.textBaseline = 'middle';
                    ctx.fillText(dateText, iconX + logoSize + gap, leftBoxY + (boxHeight / 2) + (fontSize * 0.05));

                    // Right Box Content
                    ctx.fillText(dayText, rightBoxX + paddingX, rightBoxY + (boxHeight / 2) + (fontSize * 0.05));
                }
                APP.animationId = requestAnimationFrame(draw);
            }
            draw();
        }

        // --- RECORDING LIFECYCLE ---
        
        DOM.btnRecord.addEventListener('click', () => {
            vibrate(HAPTIC.success); // Success feeling for starting record
            startRecording();
        });

        function startRecording() {
            if (!APP.cameraStream) return;
            
            DOM.btnRecord.disabled = true;
            DOM.recIcon.classList.replace('rounded-sm', 'rounded-full');
            DOM.recIcon.classList.add('animate-pulse');
            DOM.statusText.textContent = "Recording...";
            APP.recordedChunks = [];

            // 1. Flash Logic (ON) - Screen Flash Fallback
            if (APP.flashEnabled) {
                if (APP.hasTorch) {
                    applyTorch(true);
                } else {
                    // Warm white screen flash via CSS
                    DOM.cameraContainer.classList.add('flash-active');
                }
            }

            // 2. Codec Selection
            const mimeOptions = ["video/webm;codecs=vp8", "video/webm", "video/mp4"];
            const selectedMime = mimeOptions.find(type => MediaRecorder.isTypeSupported(type));

            try {
                const canvasStream = DOM.processingCanvas.captureStream(30); 
                const audioTracks = APP.cameraStream.getAudioTracks();
                if (audioTracks.length > 0) canvasStream.addTrack(audioTracks[0]);

                APP.mediaRecorder = new MediaRecorder(canvasStream, { 
                    mimeType: selectedMime,
                    videoBitsPerSecond: 2500000 
                });
            } catch (e) {
                DOM.statusText.textContent = "Rec Error: " + e.message;
                return;
            }

            APP.mediaRecorder.ondataavailable = (e) => { 
                if (e.data && e.data.size > 0) APP.recordedChunks.push(e.data); 
            };
            
            APP.mediaRecorder.onstop = async () => {
                // 3. Flash Logic (OFF)
                if (APP.flashEnabled) {
                    if (APP.hasTorch) {
                        applyTorch(false);
                    } else {
                        DOM.cameraContainer.classList.remove('flash-active');
                    }
                }

                const blob = new Blob(APP.recordedChunks, { type: selectedMime.split(';')[0] });
                
                if (blob.size < 5000) {
                    DOM.statusText.textContent = "Error: File too small. Try again.";
                    vibrate(HAPTIC.warning);
                    setTimeout(() => resetRecorderUI(), 2000);
                    return;
                }

                await handleRecordingComplete(blob);
            };

            // 4. Determine Duration (1s Self / 3s Scene)
            const recordDuration = APP.mode === 'scene' ? 3000 : 1000;
            // REMOVED BUFFER TO FIX DURATION BUG

            APP.mediaRecorder.start(); 

            // UI Animation based on duration
            const circumference = 45 * 2 * Math.PI;
            DOM.progressCircle.style.strokeDashoffset = circumference;
            requestAnimationFrame(() => {
                DOM.progressCircle.style.transition = `stroke-dashoffset ${recordDuration/1000}s linear`;
                DOM.progressCircle.style.strokeDashoffset = '0';
            });

            // 5. Stop after duration
            setTimeout(() => {
                if (APP.mediaRecorder.state === 'recording') APP.mediaRecorder.stop();
            }, recordDuration); // Removed buffer
        }

        async function handleRecordingComplete(blob) {
            await saveClip(APP.targetDate, APP.mode, blob);
            downloadFile(blob, `${APP.mode}_${formatDateDisplay(APP.targetDate)}.webm`);
            await renderCalendar();
            showDoneState(blob);
            vibrate(HAPTIC.success); // Success feeling for save complete
        }

        function showDoneState(blob) {
            // Stop camera to save battery/resources while viewing result
            if(APP.cameraStream) {
               APP.cameraStream.getTracks().forEach(t => t.stop());
               APP.cameraStream = null;
               if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.playbackPreview.src = URL.createObjectURL(blob);
            DOM.playbackPreview.classList.remove('hidden');
            DOM.cameraPreview.classList.add('hidden');
            DOM.doneOverlay.classList.remove('hidden');
            DOM.recordControls.classList.add('hidden');
            DOM.btnFlash.classList.add('hidden');
            DOM.btnSwitchCam.classList.add('hidden');
            DOM.statusText.textContent = "Saved.";
            
            DOM.btnViewClip.onclick = () => {
                vibrate(HAPTIC.tap);
                DOM.modalVideo.src = URL.createObjectURL(blob);
                DOM.modalDateDisplay.textContent = formatDateDisplay(APP.targetDate);
                DOM.clipModal.classList.remove('hidden');
                DOM.clipModal.classList.add('flex');
            };
        }
        
        function resetRecorderUI() {
             DOM.doneOverlay.classList.add('hidden');
             DOM.playbackPreview.classList.add('hidden');
             DOM.cameraPreview.classList.remove('hidden');
             
             // If we stopped stream, we need to show Init button
             if (!APP.cameraStream) {
                 DOM.recordControls.classList.add('hidden');
                 DOM.startOverlay.classList.remove('opacity-0', 'pointer-events-none');
                 DOM.btnFlash.classList.add('hidden');
                 DOM.btnSwitchCam.classList.add('hidden');
                 DOM.statusText.textContent = "Ready";
             } else {
                 DOM.recordControls.classList.remove('hidden');
                 DOM.btnFlash.classList.remove('hidden');
                 if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');
             }
             
             showReadyState();
        }

        function showReadyState() {
            DOM.doneOverlay.classList.add('hidden');
            DOM.playbackPreview.classList.add('hidden');
            DOM.cameraPreview.classList.remove('hidden');
            
            DOM.progressCircle.style.transition = 'none';
            DOM.progressCircle.style.strokeDashoffset = 45 * 2 * Math.PI;
            DOM.btnRecord.disabled = false;
            DOM.recIcon.classList.replace('rounded-full', 'rounded-sm');
            DOM.recIcon.classList.remove('animate-pulse');
        }

        // --- COMPILATION (CANVAS BASED) ---
        
        DOM.btnCompile.addEventListener('click', async () => {
            vibrate(HAPTIC.tap);
            const clips = await getAllClips(APP.mode);
            const year = APP.viewDate.getFullYear();
            const month = String(APP.viewDate.getMonth() + 1).padStart(2, '0');
            const monthPrefix = `${year}-${month}`;
            const monthClips = clips.filter(c => c.date.startsWith(monthPrefix));
            
            // Sort by date ASC
            monthClips.sort((a, b) => a.date.localeCompare(b.date));

            if (monthClips.length < 2) { 
                DOM.statusText.textContent = "Needs 2+ clips to compile";
                vibrate(HAPTIC.warning);
                return; 
            }
            
            DOM.compileModal.classList.remove('hidden');
            DOM.compileModal.classList.add('flex');
            
            try { await compileClips(monthClips); }
            catch (err) { DOM.compileLog.innerHTML = `<span class="text-red-400">Error: ${err.message}</span>`; DOM.btnCloseModal.classList.remove('hidden'); }
        });

        DOM.btnCloseModal.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.compileModal.classList.add('hidden'); DOM.compileModal.classList.remove('flex');
        });

        async function compileClips(items) {
            const outputName = `Movie_${APP.mode}_${APP.viewDate.toISOString().slice(0,7)}`;
            DOM.compileLog.textContent = `Initializing...`;
            DOM.compileProgress.style.width = '0%';

            // 1. Setup Audio Context & Destinations
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioDest = audioCtx.createMediaStreamDestination();
            
            // 2. Setup Video Element (Hidden)
            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            video.muted = false; // Must be false to get audio data
            video.playsInline = true;
            
            const sourceNode = audioCtx.createMediaElementSource(video);
            sourceNode.connect(audioDest);

            // 3. Prepare first video to get dimensions
            const firstFileUrl = URL.createObjectURL(items[0].blob);
            video.src = firstFileUrl;
            await new Promise((resolve) => {
                video.onloadedmetadata = () => resolve();
            });

            // Use the canvas in the DOM for preview
            const canvas = DOM.compileCanvas;
            const w = video.videoWidth;
            const h = video.videoHeight;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            // 4. Setup MediaRecorder
            const canvasStream = canvas.captureStream(30); // 30 FPS
            const audioTrack = audioDest.stream.getAudioTracks()[0];
            if (audioTrack) {
                canvasStream.addTrack(audioTrack);
            }

            const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? 'video/webm; codecs=vp9' 
                : 'video/webm';
                
            const recorder = new MediaRecorder(canvasStream, {
                mimeType: mimeType,
                videoBitsPerSecond: 5000000 // 5 Mbps
            });

            const chunks = [];
            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.start();

            // 5. Playback Loop
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                DOM.compileLog.textContent = `Recording ${formatDateDisplay(item.date)} (${i + 1}/${items.length})`;
                
                if (i > 0) {
                    video.src = URL.createObjectURL(item.blob);
                    await new Promise(r => video.onloadedmetadata = r);
                }

                await playAndRecord(video, ctx, w, h);
                
                DOM.compileProgress.style.width = `${((i + 1) / items.length) * 100}%`;
            }

            // 6. Finalize
            recorder.stop();
            DOM.compileLog.textContent = `Finalizing...`;

            await new Promise(resolve => recorder.onstop = resolve);

            const blob = new Blob(chunks, { type: 'video/webm' });
            downloadFile(blob, `${outputName}.webm`);
            
            DOM.compileLog.textContent = "Done.";
            vibrate(HAPTIC.success);
            DOM.btnCloseModal.classList.remove('hidden');
            
            audioCtx.close();
        }

        /**
         * Helper: Plays video from start to finish while drawing to canvas
         */
        function playAndRecord(video, ctx, targetW, targetH) {
            return new Promise((resolve, reject) => {
                video.currentTime = 0;
                
                const draw = () => {
                    if (video.paused || video.ended) return;
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, targetW, targetH);

                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    const scale = Math.min(targetW / vw, targetH / vh);
                    const dw = vw * scale;
                    const dh = vh * scale;
                    const dx = (targetW - dw) / 2;
                    const dy = (targetH - dh) / 2;

                    ctx.drawImage(video, dx, dy, dw, dh);
                    
                    requestAnimationFrame(draw);
                };

                video.onended = () => {
                    resolve();
                };
                
                video.onerror = (e) => {
                    console.error("Video Error", e);
                    resolve(); // Skip broken videos
                };

                video.play().then(() => {
                    draw();
                }).catch(e => {
                    console.error("Play error", e);
                    resolve();
                });
            });
        }

        // --- UTILS ---
        function downloadFile(blob, name) {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }

        // --- IMPORT COMPILER LOGIC (NEW) ---
        DOM.btnImportCompile.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.remove('hidden');
            DOM.importCompileModal.classList.add('flex');
        });

        DOM.btnCloseImportModal.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.add('hidden');
            DOM.importCompileModal.classList.remove('flex');
            
            // Reset state
            APP.importState.self = [];
            APP.importState.scene = [];
            DOM.selfList.innerHTML = 'No files yet.';
            DOM.sceneList.innerHTML = 'No files yet.';
            DOM.selfCount.textContent = '0';
            DOM.sceneCount.textContent = '0';
            DOM.btnStartImportCompile.disabled = true;
            DOM.importProgressArea.classList.add('hidden');
            DOM.importDownloadLinks.classList.add('hidden');
            DOM.importDownloadLinks.innerHTML = '';
        });

        // Drag & Drop
        ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            DOM.dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault(); e.stopPropagation();
        }

        DOM.dropZone.addEventListener('dragenter', () => DOM.dropZone.classList.add('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('dragleave', () => DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('drop', handleDrop);
        
        // Click to Upload
        DOM.dropZone.addEventListener('click', () => DOM.fileInput.click());
        DOM.fileInput.addEventListener('change', (e) => processImportFiles(e.target.files));

        function handleDrop(e) {
            DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10');
            processImportFiles(e.dataTransfer.files);
        }

        function processImportFiles(fileList) {
            const files = Array.from(fileList);
            vibrate(HAPTIC.tap);

            // Reset UI for fresh batch or append? Let's reset for simplicity based on compiler.html logic
            APP.importState.self = [];
            APP.importState.scene = [];
            DOM.importDownloadLinks.classList.add('hidden');
            DOM.importDownloadLinks.innerHTML = '';

            files.forEach(file => {
                const parsed = parseFilename(file.name);
                if (parsed) {
                    const item = { file, ...parsed };
                    if (parsed.type === 'self') APP.importState.self.push(item);
                    if (parsed.type === 'scene') APP.importState.scene.push(item);
                }
            });

            // Sort
            const dateSorter = (a, b) => a.date - b.date;
            APP.importState.self.sort(dateSorter);
            APP.importState.scene.sort(dateSorter);

            renderImportLists();
            
            const hasFiles = APP.importState.self.length > 0 || APP.importState.scene.length > 0;
            DOM.btnStartImportCompile.disabled = !hasFiles;
        }

        function parseFilename(filename) {
            // Regex for self_DD-MM-YYYY or scene_DD-MM-YYYY
            const regex = /^(self|scene)_(\d{2})-(\d{2})-(\d{4}).*$/;
            const match = filename.match(regex);
            
            if (!match) return null;
            
            const [_, type, day, month, year] = match;
            const date = new Date(year, month - 1, day);
            
            return {
                type, 
                date,
                formattedDate: `${day}/${month}/${year}` // For display
            };
        }

        function renderImportLists() {
            const renderGroup = (items, container) => {
                if (items.length === 0) {
                    container.innerHTML = 'No files found.';
                    return;
                }
                container.innerHTML = items.map(item => `
                    <div class="flex justify-between items-center bg-slate-900 p-2 rounded border border-slate-800">
                        <span class="truncate">${item.file.name}</span>
                        <span class="text-[10px] bg-rose-900/30 text-rose-400 px-1.5 py-0.5 rounded">${item.formattedDate}</span>
                    </div>
                `).join('');
            };

            renderGroup(APP.importState.self, DOM.selfList);
            renderGroup(APP.importState.scene, DOM.sceneList);

            DOM.selfCount.textContent = APP.importState.self.length;
            DOM.sceneCount.textContent = APP.importState.scene.length;
        }

        DOM.btnStartImportCompile.addEventListener('click', async () => {
            if (APP.importState.isProcessing) return;
            APP.importState.isProcessing = true;
            DOM.btnStartImportCompile.disabled = true;
            DOM.importProgressArea.classList.remove('hidden');
            vibrate(HAPTIC.action);

            try {
                if (APP.importState.self.length > 0) {
                    await processImportQueue(APP.importState.self, 'self');
                }
                if (APP.importState.scene.length > 0) {
                    await processImportQueue(APP.importState.scene, 'scene');
                }
                DOM.importStatusLog.textContent = "All compilations finished!";
                vibrate(HAPTIC.success);
            } catch (err) {
                console.error(err);
                DOM.importStatusLog.textContent = "Error: " + err.message;
                vibrate(HAPTIC.warning);
            } finally {
                APP.importState.isProcessing = false;
                DOM.importDownloadLinks.classList.remove('hidden');
            }
        });

        async function processImportQueue(items, type) {
            // Filename: type_START_to_END_movie
            const startDate = formatDateDisplay(items[0].date.toISOString().split('T')[0]);
            const endDate = formatDateDisplay(items[items.length - 1].date.toISOString().split('T')[0]);
            const outputName = `${type}_${startDate}_to_${endDate}_movie`;

            DOM.importStatusLog.textContent = `Compiling ${type} clips...`;
            DOM.importProgressBar.style.width = '0%';

            // 1. Setup Audio & Video
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioDest = audioCtx.createMediaStreamDestination();
            
            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            video.muted = false; 
            video.playsInline = true;
            
            const sourceNode = audioCtx.createMediaElementSource(video);
            sourceNode.connect(audioDest);

            // 2. Prepare first video
            const firstFileUrl = URL.createObjectURL(items[0].file);
            video.src = firstFileUrl;
            await new Promise((resolve) => { video.onloadedmetadata = () => resolve(); });

            // 3. Canvas & Recorder
            const canvas = DOM.importPreviewCanvas;
            const w = video.videoWidth;
            const h = video.videoHeight;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            const canvasStream = canvas.captureStream(30);
            const audioTrack = audioDest.stream.getAudioTracks()[0];
            if (audioTrack) canvasStream.addTrack(audioTrack);

            const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? 'video/webm; codecs=vp9' 
                : 'video/webm';
                
            const recorder = new MediaRecorder(canvasStream, {
                mimeType: mimeType,
                videoBitsPerSecond: 5000000 
            });

            const chunks = [];
            recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
            recorder.start();

            // 4. Playback Loop
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                DOM.importStatusLog.textContent = `Recording ${item.file.name} (${i + 1}/${items.length})`;
                
                if (i > 0) {
                    video.src = URL.createObjectURL(item.file);
                    await new Promise(r => video.onloadedmetadata = r);
                }

                await playAndRecord(video, ctx, w, h);
                DOM.importProgressBar.style.width = `${((i + 1) / items.length) * 100}%`;
            }

            // 5. Finalize
            recorder.stop();
            DOM.importStatusLog.textContent = `Finalizing ${outputName}...`;
            await new Promise(resolve => recorder.onstop = resolve);

            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);

            // Create Download Button
            const btn = document.createElement('a');
            btn.href = url;
            btn.download = `${outputName}.webm`;
            btn.className = "block w-full bg-slate-800 hover:bg-slate-700 text-white text-center py-3 rounded-lg border border-slate-700 transition-colors font-medium text-sm";
            btn.innerHTML = `<i data-lucide="download" class="inline w-4 h-4 mr-2"></i> Download ${outputName}`;
            
            DOM.importDownloadLinks.appendChild(btn);
            lucide.createIcons();
            
            audioCtx.close();
        }

        // Boot
        initApp();
        async function initApp() {
            try {
                // Initialize Logo
                APP.logoImg = new Image();
                APP.logoImg.src = 'assets/LogoIcon-Grey.svg';
                
                await initDB();
                updateMonthLabel();
                updateTargetUI();
                renderCalendar();
            } catch(e) { console.error(e); }
        }

    </script>
</body>
</html>
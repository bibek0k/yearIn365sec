<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memory Archive</title>
    <link rel="shortcut icon" href="assets/LogoIcon.svg" type="image/x-icon">
    
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --primary: #e11d48; /* Rose-600 */
            --bg: #0f172a; /* Slate-900 */
            --surface: #1e293b; /* Slate-800 */
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            overscroll-behavior-y: none;
        }

        /* Subtle Fade In Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .camera-container {
            position: relative;
            width: 100%;
            padding-top: 133.33%; /* 3:4 Aspect Ratio (480x640) */
            background: #000;
            border-radius: 1.5rem; /* Softer corners */
            overflow: hidden;
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.6);
            transition: box-shadow 0.1s ease-in-out;
        }

        /* Screen Flash: Warm White Shadow covering everything OUTSIDE the camera container */
        .camera-container.flash-active {
            box-shadow: 0 0 0 200vmax rgba(255, 248, 235, 0.95); /* Warm White */
            z-index: 100;
        }

        .camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
        }

        /* CSS Mirroring for Preview */
        .camera-feed.mirrored {
            transform: scaleX(-1);
        }
        
        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }
        
        /* Responsive Grid for Tablet/Desktop */
        @media (min-width: 768px) {
            .calendar-grid {
                gap: 0.75rem;
            }
        }

        .day-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border-radius: 0.75rem; /* Softer */
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
        }

        .day-cell:hover {
            border-color: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .day-cell.filled {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(225, 29, 72, 0.3);
        }
        
        .day-cell.target-active {
            border-color: #3b82f6; /* Blue border for target */
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
        }

        .safe-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Premium Toggle Switch */
        .mode-toggle {
            background: rgba(30, 41, 59, 0.6); /* Glassy surface */
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 9999px;
            padding: 4px;
            display: flex;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .mode-btn {
            z-index: 10;
            flex: 1;
            text-align: center;
            padding: 8px 16px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 9999px;
            transition: color 0.3s ease;
            cursor: pointer;
            letter-spacing: 0.02em;
        }
        .mode-bg {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc(50% - 4px);
            background: var(--primary);
            border-radius: 9999px;
            box-shadow: 0 2px 8px rgba(225, 29, 72, 0.4);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Shake Animation for Invalid Input */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-4px); }
            80% { transform: translateX(4px); }
        }
        .animate-shake {
            animation: shake 0.4s ease-in-out;
        }
        
        /* Custom scrollbar for lists */
        .scrollbar-thin::-webkit-scrollbar { width: 4px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center safe-pb bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-slate-950">

    <!-- Header & Mode Switch -->
    <header class="w-full max-w-5xl px-6 py-8 flex flex-col gap-8 z-10 animate-fade-in">
        <div class="flex flex-col md:flex-row justify-between items-start md:items-end gap-6">
            <!-- Greeting Block -->
            <div class="flex flex-col gap-2">
                <h1 id="greetingLine1" class="text-3xl md:text-4xl font-bold text-white tracking-tight leading-tight drop-shadow-sm">Hi,</h1>
                <p id="greetingLine2" class="text-sm md:text-base font-medium text-slate-400 tracking-wide flex items-center gap-2">Loading...</p>
            </div>
            
            <!-- Mode Toggle -->
            <div class="mode-toggle w-48 flex-shrink-0 self-start md:self-auto">
                <div id="modeBg" class="mode-bg"></div>
                <div id="modeSelf" class="mode-btn text-white">Self</div>
                <div id="modeScene" class="mode-btn text-slate-400">Scene</div>
            </div>
        </div>
        
        <!-- Search Bar Wrapper -->
        <div class="w-full relative group">
            <div id="searchContainer" class="flex items-center gap-3 w-full transition-all duration-300 bg-slate-800/50 hover:bg-slate-800/70 border border-slate-700/50 hover:border-slate-600 focus-within:border-rose-500/50 focus-within:bg-slate-800 focus-within:ring-4 focus-within:ring-rose-500/10 rounded-2xl px-2 py-2 backdrop-blur-sm">
                
                <input type="text" id="dateSearchInput" placeholder="Jump to memory (DD-MM-YYYY or Day-X)" 
                    class="bg-transparent text-slate-200 px-3 py-2 flex-1 text-sm font-medium focus:outline-none placeholder-slate-500 transition-colors">
                
                <button id="btnSearch" class="bg-slate-700/50 hover:bg-rose-600 text-slate-300 hover:text-white p-2.5 rounded-xl transition-all duration-200">
                    <i data-lucide="search" class="w-4 h-4"></i>
                </button>
            </div>
            <!-- Error Label -->
            <div id="searchError" class="absolute -bottom-6 left-2 flex items-center gap-1.5 opacity-0 pointer-events-none transition-all duration-200 transform translate-y-[-4px]">
                <i data-lucide="alert-circle" class="w-3 h-3 text-rose-500"></i>
                <span class="text-rose-500 text-xs font-semibold tracking-wide">Error message</span>
            </div>
        </div>

        <!-- Recording Target Indicator (Subtle) -->
        <div id="targetIndicator" class="hidden w-full bg-blue-500/5 border border-blue-500/10 rounded-xl p-3 text-center backdrop-blur-md">
            <p class="text-blue-400/90 text-xs font-semibold tracking-wide">Recording for <span id="targetDateDisplay" class="text-blue-300"></span></p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="w-full max-w-5xl flex-1 px-4 flex flex-col md:flex-row gap-8 items-start justify-center">

        <!-- Recorder Section Wrapper -->
        <div class="w-full md:w-[26rem] lg:w-[28rem] flex-shrink-0 mx-auto md:mx-0 md:sticky md:top-6">
            <div id="recorderSection" class="relative">
                <div id="cameraContainer" class="camera-container">
                    <video id="cameraPreview" autoplay playsinline muted class="camera-feed hidden"></video>
                    <video id="playbackPreview" playsinline loop class="camera-feed hidden"></video>
                    
                    <!-- Start Overlay -->
                    <div id="startOverlay" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-950/40 backdrop-blur-sm z-10 transition-opacity">
                        <button id="btnInitCamera" class="bg-rose-600 hover:bg-rose-700 text-white rounded-full p-6 shadow-xl shadow-rose-900/20 transform transition-all duration-300 hover:scale-105 active:scale-95">
                            <i data-lucide="camera" class="w-8 h-8"></i>
                        </button>
                        <p class="mt-5 text-sm font-semibold text-white/90 tracking-wide">Tap to Capture</p>
                    </div>

                    <!-- Done Overlay -->
                    <div id="doneOverlay" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-slate-950/80 backdrop-blur-md z-20">
                        <div class="bg-emerald-500/20 text-emerald-400 p-4 rounded-full mb-4 ring-1 ring-emerald-500/30">
                            <i data-lucide="check" class="w-8 h-8"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-white tracking-tight">Memory Saved</h3>
                        <div class="flex gap-4 mt-8">
                             <button id="btnViewClip" class="text-sm font-semibold bg-slate-800 hover:bg-slate-700 text-white px-6 py-2.5 rounded-full transition-colors border border-slate-700">Review</button>
                        </div>
                    </div>

                    <!-- Camera Tools (Switch & Flash) -->
                    <div class="absolute top-5 right-5 z-30 flex flex-col gap-3">
                        <button id="btnSwitchCam" class="hidden bg-black/40 hover:bg-black/60 text-white p-2.5 rounded-full backdrop-blur-md transition-all border border-white/10">
                            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                        </button>
                        <button id="btnFlash" class="hidden bg-black/40 hover:bg-black/60 text-slate-300 p-2.5 rounded-full backdrop-blur-md transition-all border border-white/10">
                            <i id="iconFlash" data-lucide="zap-off" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>

                <!-- Controls -->
                <div class="mt-8 flex items-center justify-center relative h-24">
                    <div id="recordControls" class="relative hidden">
                        <svg class="progress-ring w-24 h-24" viewBox="0 0 100 100">
                            <circle class="text-slate-800" stroke="currentColor" stroke-width="3" fill="transparent" r="45" cx="50" cy="50"/>
                            <circle id="progressCircle" class="progress-ring__circle text-rose-500 drop-shadow-[0_0_8px_rgba(225,29,72,0.6)]" stroke="currentColor" stroke-width="3" fill="transparent" r="45" cx="50" cy="50" stroke-dasharray="282.74" stroke-dashoffset="282.74"/>
                        </svg>
                        
                        <button id="btnRecord" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-20 h-20 bg-rose-600 rounded-full border-[6px] border-slate-950 shadow-2xl active:scale-90 transition-transform flex items-center justify-center group">
                            <div id="recIcon" class="w-8 h-8 bg-white rounded-sm group-hover:scale-90 transition-transform duration-200"></div>
                        </button>
                    </div>
                    <p id="statusText" class="absolute -bottom-4 text-[10px] uppercase tracking-widest text-slate-500 font-bold opacity-0 transition-opacity duration-300">Ready</p>
                </div>
            </div>
        </div>

        <!-- Hidden Canvas for recording processing -->
        <canvas id="processingCanvas" class="hidden"></canvas>

        <!-- Month Grid View -->
        <div class="w-full md:flex-1 bg-slate-800/40 border border-slate-700/30 rounded-2xl p-6 flex flex-col gap-6 backdrop-blur-sm">
            <!-- Month Navigation -->
            <div class="flex justify-between items-center px-1">
                <button id="btnPrevMonth" class="p-2 hover:bg-slate-700/50 rounded-full text-slate-400 hover:text-white transition-colors"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                <h2 id="monthLabel" class="text-sm font-bold text-slate-200 uppercase tracking-widest">Month</h2>
                <button id="btnNextMonth" class="p-2 hover:bg-slate-700/50 rounded-full text-slate-400 hover:text-white transition-colors"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
            </div>

            <!-- Grid -->
            <div id="calendarGrid" class="calendar-grid">
                <!-- Days injected by JS -->
            </div>

            <!-- Tools -->
            <div class="flex gap-3 justify-center border-t border-slate-700/50 pt-6">
                <button id="btnCompile" class="text-xs font-semibold bg-slate-800 hover:bg-slate-700 text-slate-200 px-5 py-2.5 rounded-lg flex items-center gap-2 transition-all border border-slate-700 hover:border-slate-600">
                    <i data-lucide="film" class="w-3.5 h-3.5"></i> Compile Month
                </button>
                <button id="btnImportCompile" class="text-xs font-semibold bg-slate-800 hover:bg-slate-700 text-slate-200 px-5 py-2.5 rounded-lg flex items-center gap-2 transition-all border border-slate-700 hover:border-slate-600">
                    <i data-lucide="upload" class="w-3.5 h-3.5"></i> Import & Compile
                </button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="w-full text-center py-8 text-slate-600 text-[10px] font-semibold uppercase tracking-widest opacity-60">
        <p>Memory Archive â€¢ Created by Bibek</p>
    </footer>

    <!-- Clip Viewer / Delete Modal -->
    <div id="clipModal" class="fixed inset-0 bg-slate-950/95 backdrop-blur-sm z-40 hidden flex-col items-center justify-center p-4 sm:p-6 transition-opacity">
        <div class="relative w-full max-w-md md:max-w-lg max-h-[90vh] overflow-y-auto bg-slate-900 rounded-2xl overflow-hidden shadow-2xl border border-slate-800 flex flex-col">
            <div class="absolute top-4 left-0 w-full flex justify-center z-10 pointer-events-none">
                <span id="modalDateDisplay" class="bg-black/60 backdrop-blur-md text-white/90 px-5 py-1.5 rounded-full text-xs font-bold tracking-wide shadow-lg border border-white/5 uppercase"></span>
            </div>
            <video id="modalVideo" controls playsinline webkit-playsinline class="w-full aspect-[3/4] bg-black block"></video>
            <div class="p-5 flex justify-between items-center bg-slate-900 sticky bottom-0 z-20 border-t border-slate-800">
                <button id="btnCloseClip" class="text-slate-400 hover:text-white text-xs font-semibold uppercase tracking-wider transition-colors px-2">Close</button>
                <div class="flex gap-3">
                    <button id="btnDownloadClip" class="bg-slate-800 hover:bg-slate-700 text-slate-200 p-2.5 rounded-full transition-colors border border-slate-700">
                        <i data-lucide="download" class="w-4 h-4"></i>
                    </button>
                    <button id="btnReplaceClip" class="bg-slate-800 hover:bg-slate-700 text-blue-400 p-2.5 rounded-full transition-colors border border-slate-700">
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                    </button>
                    <button id="btnDeleteClip" class="bg-slate-800 hover:bg-red-900/30 text-red-400 p-2.5 rounded-full transition-colors border border-slate-700 group">
                        <i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Compile Modal (Internal Clips) -->
    <div id="compileModal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-md z-50 hidden flex-col items-center justify-center p-6 text-center">
        <div class="max-w-sm w-full bg-slate-900 border border-slate-800 p-8 rounded-3xl shadow-2xl">
            <h3 class="text-xl font-bold mb-6 text-white">Compiling Movie</h3>
            <div class="relative w-full aspect-video bg-black rounded-xl overflow-hidden mb-6 border border-slate-800 shadow-inner">
                <canvas id="compileCanvas" class="w-full h-full object-contain"></canvas>
            </div>
            <div class="w-full bg-slate-800 h-1.5 rounded-full overflow-hidden mb-3">
                <div id="compileProgress" class="bg-rose-500 h-full w-0 transition-all duration-300 rounded-full"></div>
            </div>
            <p id="compileLog" class="text-[10px] text-slate-500 font-mono uppercase tracking-wider mb-6">Initializing...</p>
            <button id="btnCloseModal" class="hidden w-full bg-slate-800 text-white py-3.5 rounded-xl hover:bg-slate-700 transition-colors font-semibold text-sm">Close</button>
        </div>
    </div>

    <!-- NEW: Import & Compile Modal -->
    <div id="importCompileModal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-md z-50 hidden flex-col items-center justify-center p-4 sm:p-6 overflow-y-auto">
        <div class="relative w-full max-w-2xl bg-slate-900 border border-slate-800 p-8 rounded-3xl shadow-2xl flex flex-col gap-6 max-h-[90vh]">
            <h3 id="importModalTitle" class="text-xl font-bold text-center text-white">Import Memories</h3>
            
            <!-- Import Content Area -->
            <div id="importContentArea" class="flex flex-col gap-6 w-full">
                <!-- Drop Zone -->
                <label id="dropZone" class="border-2 border-dashed border-slate-700 hover:border-rose-500/50 hover:bg-rose-500/5 bg-slate-800/30 rounded-2xl p-10 text-center transition-all cursor-pointer flex flex-col items-center gap-3 group">
                    <input type="file" id="fileInput" multiple accept="video/*" class="hidden">
                    <div class="p-4 bg-slate-800 rounded-full group-hover:scale-110 transition-transform duration-300">
                        <i data-lucide="upload-cloud" class="w-8 h-8 text-rose-500"></i>
                    </div>
                    <strong class="text-slate-200 mt-2">Click or Drag Videos Here</strong>
                    <p class="text-xs text-slate-500">Supports: username_self_DD-MM-YYYY.* or scene_DD-MM-YYYY.*</p>
                </label>

                <!-- File Lists Container - Dynamic Per User -->
                <div id="importListContainer" class="flex flex-col gap-6 w-full max-h-[40vh] overflow-y-auto scrollbar-thin pr-1">
                    <p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>
                </div>
            </div>

            <!-- Progress & Preview Area (Hidden initially) -->
            <div id="importProgressArea" class="hidden flex flex-col gap-6 items-center w-full animate-fade-in">
                 <div class="relative w-full aspect-video bg-black rounded-xl overflow-hidden border border-slate-800 shadow-2xl shadow-rose-900/10">
                    <canvas id="importPreviewCanvas" class="w-full h-full object-contain"></canvas>
                    
                    <!-- Processing Badge Overlay -->
                    <div class="absolute top-4 left-4 bg-rose-600/90 backdrop-blur text-white text-[10px] font-bold px-3 py-1 rounded-full shadow-lg uppercase tracking-wide flex items-center gap-2">
                        <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
                        Processing
                    </div>
                </div>
                
                <div class="w-full flex flex-col gap-2">
                    <div class="flex justify-between items-end">
                         <p id="importStatusLog" class="text-xs text-slate-300 font-semibold tracking-wide">Initializing...</p>
                         <p id="importPercentDisplay" class="text-xs text-slate-500 font-mono">0%</p>
                    </div>
                    <div class="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                        <div id="importProgressBar" class="bg-gradient-to-r from-rose-500 to-rose-400 h-full w-0 transition-all duration-300 rounded-full"></div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="flex flex-col gap-3 mt-2">
                <button id="btnStartImportCompile" class="w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3.5 rounded-xl transition-all shadow-lg shadow-rose-900/20 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none" disabled>
                    Compile Files
                </button>
                <div id="importDownloadLinks" class="flex flex-col gap-2 hidden w-full">
                    <!-- Download buttons injected here -->
                </div>
                <button id="btnCloseImportModal" class="w-full text-slate-400 hover:text-white text-sm py-2 transition-colors">Close</button>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- STATE & CONFIG ---
        const APP = {
            dbName: 'OneSecondADayDB',
            storeName: 'clips',
            version: 1,
            db: null,
            today: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            mediaRecorder: null,
            recordedChunks: [],
            cameraStream: null,
            
            // New State for V2
            mode: 'self', // 'self' or 'scene'
            viewDate: new Date(), // Tracks month view
            targetDate: (() => {
                const d = new Date();
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            sceneCamFacing: 'environment', // default rear for scene
            
            // Rendering loop
            animationId: null,

            // Flash State
            flashEnabled: false,
            hasTorch: false,
            trackRef: null,
            
            // Import Compiler State
            importState: {
                files: [], // Flat list of all imported files
                isProcessing: false
            },
            
            // Recording State (Audio Logic)
            recAudioCtx: null,

            // User Data
            userName: localStorage.getItem('user_name') || null,

            // Assets
            logoImg: null
        };

        const DOM = {
            // Displays
            greetingLine1: document.getElementById('greetingLine1'),
            greetingLine2: document.getElementById('greetingLine2'),
            targetDateDisplay: document.getElementById('targetDateDisplay'),
            targetIndicator: document.getElementById('targetIndicator'),
            monthLabel: document.getElementById('monthLabel'),
            statusText: document.getElementById('statusText'),
            
            // Search
            dateSearchInput: document.getElementById('dateSearchInput'),
            btnSearch: document.getElementById('btnSearch'),
            searchContainer: document.getElementById('searchContainer'),
            searchError: document.getElementById('searchError'),

            // Camera
            cameraContainer: document.getElementById('cameraContainer'),
            cameraPreview: document.getElementById('cameraPreview'),
            playbackPreview: document.getElementById('playbackPreview'),
            processingCanvas: document.getElementById('processingCanvas'), 
            
            // Mode Switcher
            modeSelf: document.getElementById('modeSelf'),
            modeScene: document.getElementById('modeScene'),
            modeBg: document.getElementById('modeBg'),
            
            // Overlays & Buttons
            startOverlay: document.getElementById('startOverlay'),
            doneOverlay: document.getElementById('doneOverlay'),
            btnInit: document.getElementById('btnInitCamera'),
            btnRecord: document.getElementById('btnRecord'),
            btnSwitchCam: document.getElementById('btnSwitchCam'),
            btnViewClip: document.getElementById('btnViewClip'),
            btnFlash: document.getElementById('btnFlash'),
            iconFlash: document.getElementById('iconFlash'),

            // Grid & Nav
            calendarGrid: document.getElementById('calendarGrid'),
            btnPrevMonth: document.getElementById('btnPrevMonth'),
            btnNextMonth: document.getElementById('btnNextMonth'),
            
            // Modals
            clipModal: document.getElementById('clipModal'),
            modalVideo: document.getElementById('modalVideo'),
            modalDateDisplay: document.getElementById('modalDateDisplay'),
            btnCloseClip: document.getElementById('btnCloseClip'),
            btnDeleteClip: document.getElementById('btnDeleteClip'),
            btnReplaceClip: document.getElementById('btnReplaceClip'),
            btnDownloadClip: document.getElementById('btnDownloadClip'),
            
            // Compile
            btnCompile: document.getElementById('btnCompile'),
            compileModal: document.getElementById('compileModal'),
            compileProgress: document.getElementById('compileProgress'),
            compileLog: document.getElementById('compileLog'),
            btnCloseModal: document.getElementById('btnCloseModal'),
            compileCanvas: document.getElementById('compileCanvas'),
            
            // Import Compiler
            btnImportCompile: document.getElementById('btnImportCompile'),
            importCompileModal: document.getElementById('importCompileModal'),
            importModalTitle: document.getElementById('importModalTitle'),
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            importContentArea: document.getElementById('importContentArea'),
            importListContainer: document.getElementById('importListContainer'),
            btnStartImportCompile: document.getElementById('btnStartImportCompile'),
            importProgressArea: document.getElementById('importProgressArea'),
            importPreviewCanvas: document.getElementById('importPreviewCanvas'),
            importProgressBar: document.getElementById('importProgressBar'),
            importStatusLog: document.getElementById('importStatusLog'),
            importPercentDisplay: document.getElementById('importPercentDisplay'),
            importDownloadLinks: document.getElementById('importDownloadLinks'),
            btnCloseImportModal: document.getElementById('btnCloseImportModal'),

            // Icons & Rings
            recordControls: document.getElementById('recordControls'),
            progressCircle: document.getElementById('progressCircle'),
            recIcon: document.getElementById('recIcon')
        };

        // --- INIT ---
        function getSafeUsername() {
            if (!APP.userName) return 'User';
            let name = APP.userName.replace(/\/BB$/, '');
            return name.replace(/[^a-zA-Z0-9-_]/g, '');
        }

        function formatDateDisplay(isoDateString) {
            if (!isoDateString) return '';
            
            if (isoDateString instanceof Date) {
                const y = isoDateString.getFullYear();
                const m = String(isoDateString.getMonth() + 1).padStart(2, '0');
                const d = String(isoDateString.getDate()).padStart(2, '0');
                return `${d}-${m}-${y}`;
            }

            if (typeof isoDateString !== 'string') return String(isoDateString);

            if (isoDateString.includes('-')) {
                const parts = isoDateString.split('-');
                if (parts.length === 3) {
                    const [y, m, d] = parts;
                    return `${d}-${m}-${y}`;
                }
            }
            return String(isoDateString);
        }

        // --- GREETING LOGIC ---
        function updateGreeting() {
            const now = new Date();
            const hour = now.getHours();
            let timeGreeting = "Good morning";
            if (hour >= 12 && hour < 17) timeGreeting = "Good afternoon";
            else if (hour >= 17) timeGreeting = "Good evening";

            const dateOptions = { weekday: 'long', month: 'long', day: 'numeric' };
            const dateStr = now.toLocaleDateString('en-US', dateOptions);

            const name = APP.userName;
            let nameGreeting = "Hi,"; 

            if (name === "Barnita/BB") {
                const adjectives = ["gorgeous", "majestic", "lovely", "radiant", "elegant", "stunning"];
                const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
                nameGreeting = `Hi, ${randomAdj} Barnita,`;
            } else if (name === "Bibek/BB") {
                nameGreeting = "Hi Bibek boss,";
            } else {
                const cleanName = name ? name.replace(/\/BB$/, '') : '';
                nameGreeting = cleanName ? `Hi ${cleanName},` : "Hi,";
            }

            DOM.greetingLine1.textContent = nameGreeting;
            DOM.greetingLine2.innerHTML = `${timeGreeting} <span class="mx-2 text-slate-600 font-light text-lg align-middle">&bull;</span> ${dateStr}`;
        }

        // --- HAPTICS UTILITY ---
        const HAPTIC = {
            tap: 35,
            action: 75,
            success: 100,
            warning: 200,
            destructive: [100, 50, 150]
        };

        function vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }
        
        // --- DATABASE ---
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(APP.dbName, APP.version);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(APP.storeName)) {
                        db.createObjectStore(APP.storeName, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => { APP.db = e.target.result; resolve(APP.db); };
                request.onerror = (e) => reject(e);
            });
        }

        function getKey(date, mode) {
            return `${mode}_${date}`;
        }

        async function saveClip(date, mode, blob) {
            const id = getKey(date, mode);
            return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.put({ id: id, date: date, mode: mode, blob: blob, timestamp: Date.now() });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getClip(date, mode) {
            if (!APP.db) return null;
            const id = getKey(date, mode);
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        }
        
        async function deleteClip(date, mode) {
            const id = getKey(date, mode);
             return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getAllClips(mode) {
             if (!APP.db) return [];
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).getAll();
                req.onsuccess = () => {
                    const all = req.result || [];
                    resolve(all.filter(c => c.mode === mode));
                };
            });
        }

        // --- SEARCH LOGIC ---
        DOM.btnSearch.addEventListener('click', () => {
            vibrate(HAPTIC.tap); 
            handleSearch();
        });
        DOM.dateSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });

        DOM.dateSearchInput.addEventListener('input', () => {
             DOM.searchError.classList.add('opacity-0', 'pointer-events-none');
             DOM.searchError.classList.remove('translate-y-0');
             DOM.searchError.classList.add('translate-y-[-4px]');
             
             DOM.searchContainer.classList.remove('border-rose-500/50', 'ring-2', 'ring-rose-500/20');
             DOM.searchContainer.classList.add('border-slate-700/50');
        });

        function triggerSearchError(msg) {
            DOM.searchError.querySelector('span').textContent = msg;
            DOM.searchError.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-[-4px]');
            DOM.searchError.classList.add('translate-y-0');
            DOM.searchContainer.classList.remove('border-slate-700/50');
            DOM.searchContainer.classList.add('border-rose-500/50', 'ring-2', 'ring-rose-500/20');
            vibrate(HAPTIC.warning);
            DOM.searchContainer.classList.add('animate-shake');
            setTimeout(() => DOM.searchContainer.classList.remove('animate-shake'), 400);
        }

        async function handleSearch() {
            const input = DOM.dateSearchInput.value.trim();
            const dateRegex = /^(\d{2})-(\d{2})-(\d{4})$/;
            const dayRegex = /^Day-(\d+)$/i;

            let isoDate;
            let targetYear, targetMonth;

            if (dayRegex.test(input)) {
                const match = input.match(dayRegex);
                const dayNum = parseInt(match[1], 10);
                const currentYear = new Date().getFullYear();
                
                if (dayNum < 1 || dayNum > 366) {
                    triggerSearchError("Invalid Day Number");
                    return;
                }

                const calculatedDate = new Date(currentYear, 0, dayNum);
                if (calculatedDate.getFullYear() !== currentYear) {
                     triggerSearchError(`Day-${dayNum} does not exist in ${currentYear}`);
                     return;
                }

                const y = calculatedDate.getFullYear();
                const m = String(calculatedDate.getMonth() + 1).padStart(2, '0');
                const d = String(calculatedDate.getDate()).padStart(2, '0');
                isoDate = `${y}-${m}-${d}`;
                
                targetYear = y;
                targetMonth = calculatedDate.getMonth();

            } else if (dateRegex.test(input)) {
                const match = input.match(dateRegex);
                const [_, d, m, y] = match;
                isoDate = `${y}-${m}-${d}`;
                
                const testDate = new Date(isoDate);
                if (isNaN(testDate.getTime()) || testDate.getMonth() + 1 !== parseInt(m)) {
                    triggerSearchError("Date does not exist");
                    return;
                }
                
                targetYear = Number(y);
                targetMonth = Number(m) - 1;

            } else {
                triggerSearchError("Format: DD-MM-YYYY or Day-X");
                return;
            }

            const clip = await getClip(isoDate, APP.mode);
            if (clip && clip.blob && clip.blob.size > 0) {
                vibrate(HAPTIC.success);
                DOM.searchError.classList.add('opacity-0', 'pointer-events-none');
                DOM.searchContainer.classList.remove('border-rose-500/50', 'ring-2');
                DOM.searchContainer.classList.add('border-slate-700/50');
                APP.viewDate = new Date(targetYear, targetMonth, 1);
                updateMonthLabel();
                await renderCalendar();
                openClipModal(isoDate); 
            } else {
                triggerSearchError("No recording found.");
            }
        }

        // --- VIEW & NAVIGATION LOGIC ---

        function updateMonthLabel() {
            DOM.monthLabel.textContent = APP.viewDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        async function renderCalendar() {
            const clips = await getAllClips(APP.mode);
            const validClips = clips.filter(c => c.blob && c.blob.size > 0);
            const clipMap = new Map(validClips.map(c => [c.date, c]));
            
            DOM.calendarGrid.innerHTML = '';
            
            const year = APP.viewDate.getFullYear();
            const month = APP.viewDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                const dateObj = new Date(year, month, d);
                const dayOfYear = getDayOfYear(dateObj);
                
                const el = document.createElement('div');
                el.className = 'day-cell';
                el.title = formatDateDisplay(dateStr);
                
                const clip = clipMap.get(dateStr);
                const isTarget = dateStr === APP.targetDate;

                el.innerHTML = `<span class="text-[10px] font-bold opacity-60">Day</span><span class="text-lg font-bold leading-none mt-0.5">${dayOfYear}</span>`;

                if (clip) {
                    el.classList.add('filled');
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        openClipModal(clip);
                    };
                } else {
                    el.onclick = () => {
                        vibrate(HAPTIC.tap);
                        setTargetDate(dateStr);
                    };
                }

                if (isTarget) {
                    el.classList.add('target-active');
                }

                DOM.calendarGrid.appendChild(el);
            }
        }

        DOM.btnPrevMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() - 1);
            updateMonthLabel();
            renderCalendar();
        });

        DOM.btnNextMonth.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.viewDate.setMonth(APP.viewDate.getMonth() + 1);
            updateMonthLabel();
            renderCalendar();
        });

        // --- MODE SWITCHING ---

        function setMode(mode) {
            APP.mode = mode;
            APP.targetDate = APP.today;
            updateTargetUI();
            
            if (mode === 'self') {
                DOM.modeSelf.classList.replace('text-slate-400', 'text-white');
                DOM.modeScene.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(0)';
                DOM.btnSwitchCam.classList.add('hidden');
                DOM.cameraPreview.classList.add('mirrored');
            } else {
                DOM.modeScene.classList.replace('text-slate-400', 'text-white');
                DOM.modeSelf.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(100%)';
                DOM.cameraPreview.classList.remove('mirrored');
                if(APP.cameraStream) DOM.btnSwitchCam.classList.remove('hidden');
            }
            
            renderCalendar();
            resetRecorderUI();
            if (APP.cameraStream) startCamera(); 
        }

        DOM.modeSelf.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('self'); });
        DOM.modeScene.addEventListener('click', () => { vibrate(HAPTIC.tap); setMode('scene'); });

        // --- REPLACE / TARGET LOGIC ---

        function setTargetDate(date) {
            APP.targetDate = date;
            updateTargetUI();
            resetRecorderUI();
            renderCalendar();
        }
        
        function updateTargetUI() {
            DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
            if (APP.targetDate !== APP.today) {
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;
                DOM.statusText.classList.remove('opacity-0');
            } else {
                DOM.targetIndicator.classList.add('hidden');
                DOM.statusText.textContent = "Ready";
                DOM.statusText.classList.remove('opacity-0');
            }
            checkTargetStatus();
        }
        
        async function checkTargetStatus() {
            const existing = await getClip(APP.targetDate, APP.mode);
            if (existing && existing.blob && existing.blob.size > 0) {
                showDoneState(existing.blob);
            } else {
                showReadyState();
            }
        }

        async function openClipModal(clipOrDate) {
            let clip;
            let date;

            if (typeof clipOrDate === 'string') {
                date = clipOrDate;
                clip = await getClip(date, APP.mode);
            } else {
                clip = clipOrDate;
                date = clip.date;
            }

            if (!clip || !clip.blob || clip.blob.size === 0) {
                triggerSearchError("Error: Valid recording not found");
                return;
            }
            
            try {
                const safeMode = clip.mode || APP.mode;
                const safeName = getSafeUsername();
                const fileName = `${safeName}_${safeMode}_${formatDateDisplay(date)}.webm`;
                const file = new File([clip.blob], fileName, { type: clip.blob.type });
                
                DOM.modalVideo.src = URL.createObjectURL(file);
                DOM.modalDateDisplay.textContent = formatDateDisplay(date);
                DOM.clipModal.classList.remove('hidden');
                DOM.clipModal.classList.add('flex');

                DOM.btnDownloadClip.onclick = () => {
                    vibrate(HAPTIC.tap);
                    downloadFile(clip.blob, fileName);
                };

            } catch (e) {
                console.error("Error displaying video", e);
                DOM.statusText.textContent = "Error: Video unavailable";
                return;
            }
            
            DOM.btnDeleteClip.onclick = async () => {
                if (DOM.btnDeleteClip.dataset.state === 'confirm') {
                    vibrate(HAPTIC.destructive);
                    await deleteClip(date, APP.mode);
                    DOM.clipModal.classList.add('hidden');
                    DOM.clipModal.classList.remove('flex');
                    await renderCalendar();
                    setTargetDate(APP.today);
                    DOM.btnDeleteClip.dataset.state = '';
                    DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>';
                    lucide.createIcons();
                } else {
                    vibrate(HAPTIC.warning);
                    DOM.btnDeleteClip.dataset.state = 'confirm';
                    DOM.btnDeleteClip.innerHTML = '<div class="w-4 h-4 flex items-center justify-center"><span class="text-red-400 font-extrabold text-sm">?</span></div>';
                    setTimeout(() => {
                        if (DOM.btnDeleteClip.dataset.state === 'confirm') {
                            DOM.btnDeleteClip.dataset.state = '';
                            DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>';
                            lucide.createIcons();
                        }
                    }, 3000);
                }
            };

            DOM.btnReplaceClip.onclick = () => {
                vibrate(HAPTIC.tap); 
                DOM.clipModal.classList.add('hidden');
                DOM.clipModal.classList.remove('flex');
                DOM.modalVideo.pause();
                APP.targetDate = date;
                DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate);
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`;
                showReadyState();
            };
        }
        
        DOM.btnCloseClip.addEventListener('click', () => {
            DOM.btnDeleteClip.dataset.state = '';
            DOM.btnDeleteClip.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 group-hover:scale-110 transition-transform"></i>';
            lucide.createIcons();
            vibrate(HAPTIC.tap);
            DOM.clipModal.classList.add('hidden');
            DOM.clipModal.classList.remove('flex');
            DOM.modalVideo.pause();
        });

        // --- CAMERA & FLASH LOGIC ---
        
        DOM.btnInit.addEventListener('click', () => { 
            vibrate(HAPTIC.action); 
            startCamera(); 
        });
        
        DOM.btnSwitchCam.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            APP.sceneCamFacing = APP.sceneCamFacing === 'environment' ? 'user' : 'environment';
            startCamera();
        });

        DOM.btnFlash.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            toggleFlashState();
        });

        function toggleFlashState() {
            APP.flashEnabled = !APP.flashEnabled;
            updateFlashUI();
        }

        function updateFlashUI() {
            if (APP.flashEnabled) {
                DOM.btnFlash.classList.replace('text-slate-300', 'text-yellow-400');
                DOM.iconFlash.setAttribute('data-lucide', 'zap');
            } else {
                DOM.btnFlash.classList.replace('text-yellow-400', 'text-slate-300');
                DOM.iconFlash.setAttribute('data-lucide', 'zap-off');
            }
            lucide.createIcons();
        }

        async function applyTorch(state) {
            if (APP.hasTorch && APP.trackRef) {
                try {
                    await APP.trackRef.applyConstraints({ advanced: [{ torch: state }] });
                } catch (e) {
                    console.warn("Torch failed", e);
                }
            }
        }

        async function startCamera() {
             if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                DOM.statusText.textContent = "Error: HTTPS Required";
                return;
            }

            if (APP.cameraStream) {
                APP.cameraStream.getTracks().forEach(t => t.stop());
                if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.statusText.textContent = "Starting camera...";
            let constraints = { 
                audio: true, 
                video: {
                    facingMode: APP.mode === 'self' ? 'user' : { ideal: APP.sceneCamFacing }
                } 
            };

            try {
                APP.cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                DOM.cameraPreview.srcObject = APP.cameraStream;
                await DOM.cameraPreview.play();
                DOM.cameraPreview.classList.remove('hidden');
                DOM.playbackPreview.classList.add('hidden');
                DOM.startOverlay.classList.add('opacity-0', 'pointer-events-none');
                DOM.recordControls.classList.remove('hidden');
                DOM.statusText.textContent = `Ready (${APP.mode})`;
                DOM.statusText.classList.remove('opacity-0');
                
                if (APP.mode === 'self') {
                    DOM.cameraPreview.classList.add('mirrored');
                } else {
                    DOM.cameraPreview.classList.remove('mirrored');
                }

                DOM.btnFlash.classList.remove('hidden');
                if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');

                const track = APP.cameraStream.getVideoTracks()[0];
                APP.trackRef = track;
                const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                APP.hasTorch = !!capabilities.torch;
                
                updateCanvasLoop();

            } catch (err) {
                console.error(err);
                DOM.statusText.textContent = "Error: " + err.name;
            }
        }

        function updateCanvasLoop() {
            const ctx = DOM.processingCanvas.getContext('2d');
            const video = DOM.cameraPreview;
            const canvas = DOM.processingCanvas;

            const roundRect = (x, y, w, h, r) => {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y, x + h, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            };

            function draw() {
                if (video.readyState >= 2) { 
                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    
                    if (canvas.width !== vw || canvas.height !== vh) {
                        canvas.width = vw;
                        canvas.height = vh;
                    }

                    const cw = canvas.width;
                    const ch = canvas.height;

                    ctx.save();
                    if (APP.mode === 'self') {
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.filter = 'none';
                    ctx.drawImage(video, 0, 0, cw, ch);
                    ctx.restore();

                    // --- WATERMARK LOGIC ---
                    const margin = cw * 0.04;
                    const boxHeight = cw * 0.065;
                    const boxRadius = boxHeight / 2;
                    const fontSize = boxHeight * 0.45;
                    const paddingX = boxHeight * 0.5;
                    
                    const [y, m, d] = APP.targetDate.split('-');
                    const dateObj = new Date(Number(y), Number(m)-1, Number(d));
                    const dateText = dateObj.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }).toUpperCase();
                    const dayNum = getDayOfYear(dateObj);
                    const dayText = `DAY ${dayNum}`;

                    ctx.font = `700 ${fontSize}px "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                    const logoSize = boxHeight * 0.6;
                    const gap = boxHeight * 0.4;
                    
                    const leftTextWidth = ctx.measureText(dateText).width;
                    const leftBoxWidth = paddingX + logoSize + gap + leftTextWidth + paddingX;
                    const leftBoxX = margin;
                    const leftBoxY = ch - margin - boxHeight;

                    const rightTextWidth = ctx.measureText(dayText).width;
                    const rightBoxWidth = paddingX + rightTextWidth + paddingX;
                    const rightBoxX = cw - margin - rightBoxWidth;
                    const rightBoxY = ch - margin - boxHeight;

                    ctx.save();
                    roundRect(leftBoxX, leftBoxY, leftBoxWidth, boxHeight, boxRadius);
                    roundRect(rightBoxX, rightBoxY, rightBoxWidth, boxHeight, boxRadius);
                    ctx.clip();
                    
                    if (APP.mode === 'self') {
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.filter = 'blur(12px)';
                    ctx.drawImage(video, 0, 0, cw, ch);
                    ctx.restore();

                    const overlayColor = 'rgba(15, 23, 42, 0.55)'; 
                    const textColor = '#cbcbcb'; 

                    ctx.fillStyle = overlayColor;
                    ctx.beginPath(); roundRect(leftBoxX, leftBoxY, leftBoxWidth, boxHeight, boxRadius); ctx.fill();
                    ctx.beginPath(); roundRect(rightBoxX, rightBoxY, rightBoxWidth, boxHeight, boxRadius); ctx.fill();

                    const iconY = leftBoxY + (boxHeight - logoSize) / 2;
                    const iconX = leftBoxX + paddingX;
                    
                    if (APP.logoImg && APP.logoImg.complete && APP.logoImg.naturalHeight !== 0) {
                        ctx.drawImage(APP.logoImg, iconX, iconY, logoSize, logoSize);
                    }
                    
                    ctx.fillStyle = textColor;
                    ctx.textBaseline = 'middle';
                    ctx.fillText(dateText, iconX + logoSize + gap, leftBoxY + (boxHeight / 2) + (fontSize * 0.05));
                    ctx.fillText(dayText, rightBoxX + paddingX, rightBoxY + (boxHeight / 2) + (fontSize * 0.05));
                }
                APP.animationId = requestAnimationFrame(draw);
            }
            draw();
        }

        // --- RECORDING LIFECYCLE ---
        
        DOM.btnRecord.addEventListener('click', () => {
            vibrate(HAPTIC.success);
            startRecording();
        });

        async function startRecording() {
            if (!APP.cameraStream) return;
            
            DOM.btnRecord.disabled = true;
            DOM.recIcon.classList.replace('rounded-sm', 'rounded-full');
            DOM.recIcon.classList.add('animate-pulse');
            DOM.statusText.textContent = "Recording...";
            APP.recordedChunks = [];

            if (APP.flashEnabled) {
                if (APP.hasTorch) {
                    applyTorch(true);
                } else {
                    DOM.cameraContainer.classList.add('flash-active');
                }
            }

            const mimeOptions = ["video/webm;codecs=vp8", "video/webm", "video/mp4"];
            const selectedMime = mimeOptions.find(type => MediaRecorder.isTypeSupported(type));

            try {
                const canvasStream = DOM.processingCanvas.captureStream(30); 
                
                if (APP.cameraStream.getAudioTracks().length > 0) {
                    APP.recAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const source = APP.recAudioCtx.createMediaStreamSource(APP.cameraStream);
                    const dest = APP.recAudioCtx.createMediaStreamDestination();
                    source.connect(dest);
                    const audioTrack = dest.stream.getAudioTracks()[0];
                    canvasStream.addTrack(audioTrack);
                }

                APP.mediaRecorder = new MediaRecorder(canvasStream, { 
                    mimeType: selectedMime,
                    videoBitsPerSecond: 2500000 
                });
            } catch (e) {
                DOM.statusText.textContent = "Rec Error: " + e.message;
                return;
            }

            APP.mediaRecorder.ondataavailable = (e) => { 
                if (e.data && e.data.size > 0) APP.recordedChunks.push(e.data); 
            };
            
            APP.mediaRecorder.onstop = async () => {
                if (APP.mediaRecorder.stream) {
                    APP.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }

                if (APP.recAudioCtx) {
                    try { await APP.recAudioCtx.close(); } catch(e) {}
                    APP.recAudioCtx = null;
                }

                if (APP.flashEnabled) {
                    if (APP.hasTorch) {
                        applyTorch(false);
                    } else {
                        DOM.cameraContainer.classList.remove('flash-active');
                    }
                }

                const blob = new Blob(APP.recordedChunks, { type: selectedMime.split(';')[0] });
                
                if (blob.size < 5000) {
                    DOM.statusText.textContent = "Error: File too small. Try again.";
                    vibrate(HAPTIC.warning);
                    setTimeout(() => resetRecorderUI(), 2000);
                    return;
                }

                await handleRecordingComplete(blob);
            };

            const recordDuration = APP.mode === 'scene' ? 3000 : 1000;
            APP.mediaRecorder.start(); 

            const circumference = 45 * 2 * Math.PI;
            DOM.progressCircle.style.strokeDashoffset = circumference;
            requestAnimationFrame(() => {
                DOM.progressCircle.style.transition = `stroke-dashoffset ${recordDuration/1000}s linear`;
                DOM.progressCircle.style.strokeDashoffset = '0';
            });

            setTimeout(() => {
                if (APP.mediaRecorder.state === 'recording') APP.mediaRecorder.stop();
            }, recordDuration);
        }

        async function handleRecordingComplete(blob) {
            await saveClip(APP.targetDate, APP.mode, blob);
            const safeName = getSafeUsername();
            downloadFile(blob, `${safeName}_${APP.mode}_${formatDateDisplay(APP.targetDate)}.webm`);
            await renderCalendar();
            showDoneState(blob);
            vibrate(HAPTIC.success);
        }

        function showDoneState(blob) {
            if(APP.cameraStream) {
               APP.cameraStream.getTracks().forEach(t => t.stop());
               APP.cameraStream = null;
               if(APP.animationId) cancelAnimationFrame(APP.animationId);
            }

            DOM.playbackPreview.src = URL.createObjectURL(blob);
            DOM.playbackPreview.classList.remove('hidden');
            DOM.cameraPreview.classList.add('hidden');
            DOM.doneOverlay.classList.remove('hidden');
            DOM.recordControls.classList.add('hidden');
            DOM.btnFlash.classList.add('hidden');
            DOM.btnSwitchCam.classList.add('hidden');
            DOM.statusText.textContent = "Saved.";
            
            DOM.btnViewClip.onclick = () => {
                vibrate(HAPTIC.tap);
                DOM.modalVideo.src = URL.createObjectURL(blob);
                DOM.modalDateDisplay.textContent = formatDateDisplay(APP.targetDate);
                DOM.clipModal.classList.remove('hidden');
                DOM.clipModal.classList.add('flex');
            };
        }
        
        function resetRecorderUI() {
             DOM.doneOverlay.classList.add('hidden');
             DOM.playbackPreview.classList.add('hidden');
             DOM.cameraPreview.classList.remove('hidden');
             
             if (!APP.cameraStream) {
                 DOM.recordControls.classList.add('hidden');
                 DOM.startOverlay.classList.remove('opacity-0', 'pointer-events-none');
                 DOM.btnFlash.classList.add('hidden');
                 DOM.btnSwitchCam.classList.add('hidden');
                 DOM.statusText.textContent = "Ready";
             } else {
                 DOM.recordControls.classList.remove('hidden');
                 DOM.btnFlash.classList.remove('hidden');
                 if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');
             }
             
             showReadyState();
        }

        function showReadyState() {
            DOM.doneOverlay.classList.add('hidden');
            DOM.playbackPreview.classList.add('hidden');
            DOM.cameraPreview.classList.remove('hidden');
            
            DOM.progressCircle.style.transition = 'none';
            DOM.progressCircle.style.strokeDashoffset = 45 * 2 * Math.PI;
            DOM.btnRecord.disabled = false;
            DOM.recIcon.classList.replace('rounded-full', 'rounded-sm');
            DOM.recIcon.classList.remove('animate-pulse');
        }

        // --- COMPILATION CORE (CONTEXT AWARE) ---
        
        DOM.btnCompile.addEventListener('click', async () => {
            vibrate(HAPTIC.tap);
            const clips = await getAllClips(APP.mode);
            const year = APP.viewDate.getFullYear();
            const month = String(APP.viewDate.getMonth() + 1).padStart(2, '0');
            const monthPrefix = `${year}-${month}`;
            const monthClips = clips.filter(c => c.date.startsWith(monthPrefix));
            
            monthClips.sort((a, b) => a.date.localeCompare(b.date));

            if (monthClips.length < 2) { 
                DOM.statusText.textContent = "Needs 2+ clips to compile";
                vibrate(HAPTIC.warning);
                return; 
            }
            
            DOM.compileModal.classList.remove('hidden');
            DOM.compileModal.classList.add('flex');
            
            try { 
                // Compile internal clips using internal modal UI context
                await compileClips(monthClips, getSafeUsername(), {
                    canvas: DOM.compileCanvas,
                    progress: DOM.compileProgress,
                    log: DOM.compileLog
                }); 
            }
            catch (err) { DOM.compileLog.innerHTML = `<span class="text-red-400">Error: ${err.message}</span>`; DOM.btnCloseModal.classList.remove('hidden'); }
        });

        DOM.btnCloseModal.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.compileModal.classList.add('hidden'); DOM.compileModal.classList.remove('flex');
        });

        // REFACTORED: accepts UI context to fix hidden canvas bug
        async function compileClips(items, username, uiContext) {
            const { canvas, progress, log } = uiContext;
            
            const startDate = formatDateDisplay(items[0].date);
            const endDate = formatDateDisplay(items[items.length - 1].date);
            const mode = items[0].type || APP.mode;
            
            const outputName = `${username}_${mode}_${startDate}_to_${endDate}_movie`;
            
            log.textContent = `Processing ${username}: Initializing...`;
            progress.style.width = '0%';
            if(DOM.importPercentDisplay) DOM.importPercentDisplay.textContent = '0%';

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioDest = audioCtx.createMediaStreamDestination();
            
            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            video.muted = false;
            video.playsInline = true;
            
            const sourceNode = audioCtx.createMediaElementSource(video);
            sourceNode.connect(audioDest);

            const firstFileUrl = URL.createObjectURL(items[0].blob || items[0].file);
            video.src = firstFileUrl;
            await new Promise((resolve) => {
                video.onloadedmetadata = () => resolve();
            });

            // Use passed canvas
            const w = video.videoWidth;
            const h = video.videoHeight;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            const canvasStream = canvas.captureStream(30);
            const audioTrack = audioDest.stream.getAudioTracks()[0];
            if (audioTrack) {
                canvasStream.addTrack(audioTrack);
            }

            const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? 'video/webm; codecs=vp9' 
                : 'video/webm';
                
            const recorder = new MediaRecorder(canvasStream, {
                mimeType: mimeType,
                videoBitsPerSecond: 5000000 // 5 Mbps
            });

            const chunks = [];
            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.start();

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const dateVal = item.date instanceof Date ? item.date.toISOString().split('T')[0] : item.date;
                const progressPct = Math.round(((i + 1) / items.length) * 100);
                
                log.textContent = `Processing ${username}: Clip ${i + 1}/${items.length}`;
                if(DOM.importPercentDisplay) DOM.importPercentDisplay.textContent = `${progressPct}%`;
                
                if (i > 0) {
                    video.src = URL.createObjectURL(item.blob || item.file);
                    await new Promise(r => video.onloadedmetadata = r);
                }

                await playAndRecord(video, ctx, w, h);
                
                progress.style.width = `${progressPct}%`;
            }

            recorder.stop();
            log.textContent = `Processing ${username}: Finalizing...`;

            await new Promise(resolve => recorder.onstop = resolve);

            const blob = new Blob(chunks, { type: 'video/webm' });
            downloadFile(blob, `${outputName}.webm`);
            
            audioCtx.close();
            
            // Return blob so we can append download link if needed
            return { blob, name: `${outputName}.webm` };
        }

        function playAndRecord(video, ctx, targetW, targetH) {
            return new Promise((resolve, reject) => {
                video.currentTime = 0;
                
                const draw = () => {
                    if (video.paused || video.ended) return;
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, targetW, targetH);

                    const vw = video.videoWidth;
                    const vh = video.videoHeight;
                    const scale = Math.min(targetW / vw, targetH / vh);
                    const dw = vw * scale;
                    const dh = vh * scale;
                    const dx = (targetW - dw) / 2;
                    const dy = (targetH - dh) / 2;

                    ctx.drawImage(video, dx, dy, dw, dh);
                    
                    requestAnimationFrame(draw);
                };

                video.onended = () => {
                    resolve();
                };
                
                video.onerror = (e) => {
                    console.error("Video Error", e);
                    resolve(); 
                };

                video.play().then(() => {
                    draw();
                }).catch(e => {
                    console.error("Play error", e);
                    resolve();
                });
            });
        }

        // --- UTILS ---
        function downloadFile(blob, name) {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }

        // --- IMPORT COMPILER LOGIC (FIXED) ---
        DOM.btnImportCompile.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.remove('hidden');
            DOM.importCompileModal.classList.add('flex');
        });

        DOM.btnCloseImportModal.addEventListener('click', () => {
            vibrate(HAPTIC.tap);
            DOM.importCompileModal.classList.add('hidden');
            DOM.importCompileModal.classList.remove('flex');
            
            // Reset state
            APP.importState.files = [];
            DOM.importListContainer.innerHTML = '<p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>';
            DOM.btnStartImportCompile.disabled = true;
            DOM.importProgressArea.classList.add('hidden');
            DOM.importContentArea.classList.remove('hidden'); // Show dropzone again
            DOM.importDownloadLinks.classList.add('hidden');
            DOM.importDownloadLinks.innerHTML = '';
            DOM.importModalTitle.textContent = "Import Memories";
        });

        // Drag & Drop
        ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            DOM.dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault(); e.stopPropagation();
        }

        DOM.dropZone.addEventListener('dragenter', () => DOM.dropZone.classList.add('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('dragleave', () => DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10'));
        DOM.dropZone.addEventListener('drop', handleDrop);
        
        // Click to Upload
        DOM.dropZone.addEventListener('click', () => DOM.fileInput.click());
        DOM.fileInput.addEventListener('change', (e) => processImportFiles(e.target.files));

        function handleDrop(e) {
            DOM.dropZone.classList.remove('border-rose-600', 'bg-rose-600/10');
            processImportFiles(e.dataTransfer.files);
        }

        function processImportFiles(fileList) {
            const files = Array.from(fileList);
            vibrate(HAPTIC.tap);

            // FIX: Append files instead of resetting to avoid "upload twice" confusion
            // Create a Set of existing filenames to avoid duplicates in current session
            const existingNames = new Set(APP.importState.files.map(f => f.file.name));

            let addedCount = 0;
            files.forEach(file => {
                if (!existingNames.has(file.name)) {
                    const parsed = parseFilename(file.name);
                    if (parsed) {
                        APP.importState.files.push({ file, ...parsed });
                        addedCount++;
                    }
                }
            });

            // Sort main list by date
            APP.importState.files.sort((a, b) => a.date - b.date);

            renderImportLists();
            
            const hasFiles = APP.importState.files.length > 0;
            DOM.btnStartImportCompile.disabled = !hasFiles;
            
            // Clear input so selecting same files works again if needed
            DOM.fileInput.value = ''; 
        }

        function parseFilename(filename) {
            const regexNew = /^(.*)_(self|scene)_(\d{2})-(\d{2})-(\d{4}).*$/;
            const matchNew = filename.match(regexNew);
            if (matchNew) {
                const [_, username, type, day, month, year] = matchNew;
                const date = new Date(year, month - 1, day);
                return { type, date, username, formattedDate: `${day}/${month}/${year}` };
            }

            const regexOld = /^(self|scene)_(\d{2})-(\d{2})-(\d{4}).*$/;
            const matchOld = filename.match(regexOld);
            if (matchOld) {
                const [_, type, day, month, year] = matchOld;
                const date = new Date(year, month - 1, day);
                return { type, date, username: 'Unknown', formattedDate: `${day}/${month}/${year}` };
            }
            
            return null;
        }

        function renderImportLists() {
            const container = DOM.importListContainer;
            container.innerHTML = '';

            if (APP.importState.files.length === 0) {
                container.innerHTML = '<p class="text-center text-slate-500 text-xs italic py-4">No files added yet.</p>';
                return;
            }

            // Group by User
            const filesByUser = {};
            APP.importState.files.forEach(item => {
                const user = item.username;
                if (!filesByUser[user]) filesByUser[user] = { self: [], scene: [] };
                if (item.type === 'self') filesByUser[user].self.push(item);
                if (item.type === 'scene') filesByUser[user].scene.push(item);
            });

            // Iterate Users
            for (const [username, groups] of Object.entries(filesByUser)) {
                // User Wrapper
                const userSection = document.createElement('div');
                userSection.className = 'w-full bg-slate-950/50 border border-slate-800 rounded-xl p-4 flex flex-col gap-4';
                
                // User Header
                const header = document.createElement('h3');
                header.className = 'text-sm font-bold text-white flex items-center gap-2 border-b border-slate-800 pb-2';
                header.innerHTML = `<i data-lucide="user" class="w-4 h-4 text-rose-500"></i> ${username}`;
                userSection.appendChild(header);

                // Grid for Self/Scene (New Preview Flow)
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';

                // Helper to render sub-lists
                const renderSubList = (title, items) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex flex-col gap-2';
                    wrapper.innerHTML = `<h4 class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1 flex justify-between">${title} <span class="bg-slate-800 text-slate-300 px-2 rounded-md text-[10px] border border-slate-700">${items.length}</span></h4>`;
                    const listDiv = document.createElement('div');
                    listDiv.className = 'text-xs text-slate-500 space-y-1.5 max-h-32 overflow-y-auto scrollbar-thin';
                    
                    if(items.length === 0) {
                        listDiv.innerHTML = '<span class="italic opacity-50 pl-1">No clips</span>';
                    } else {
                        items.sort((a,b) => a.date - b.date).forEach(item => {
                            listDiv.innerHTML += `
                                <div class="flex justify-between items-center bg-slate-900 p-2 rounded border border-slate-800 hover:border-slate-700 transition-colors">
                                    <span class="truncate text-xs text-white font-medium w-2/3">${item.file.name}</span>
                                    <span class="text-[10px] bg-rose-900/30 text-rose-400 px-1.5 py-0.5 rounded flex-shrink-0 font-mono">${item.formattedDate}</span>
                                </div>`;
                        });
                    }
                    wrapper.appendChild(listDiv);
                    return wrapper;
                };

                grid.appendChild(renderSubList('Self Clips', groups.self));
                grid.appendChild(renderSubList('Scene Clips', groups.scene));

                userSection.appendChild(grid);
                container.appendChild(userSection);
            }
            lucide.createIcons();
        }

        DOM.btnStartImportCompile.addEventListener('click', async () => {
            if (APP.importState.isProcessing) return;
            APP.importState.isProcessing = true;
            DOM.btnStartImportCompile.disabled = true;
            vibrate(HAPTIC.action);

            // TRANSITION TO PROCESSING VIEW
            DOM.importContentArea.classList.add('hidden'); // Hide list
            DOM.importProgressArea.classList.remove('hidden'); // Show progress
            DOM.importModalTitle.textContent = "Compiling Memories...";
            DOM.importDownloadLinks.classList.add('hidden');

            try {
                // Grouping Logic: User -> Mode -> Date
                const filesByUser = {};
                APP.importState.files.forEach(item => {
                    const user = item.username;
                    if (!filesByUser[user]) filesByUser[user] = { self: [], scene: [] };
                    if (item.type === 'self') filesByUser[user].self.push(item);
                    if (item.type === 'scene') filesByUser[user].scene.push(item);
                });

                // Context for Import Compilation (Visible Elements)
                const importUIContext = {
                    canvas: DOM.importPreviewCanvas,
                    progress: DOM.importProgressBar,
                    log: DOM.importStatusLog
                };

                // Iterate Users Sequentially
                for (const [username, groups] of Object.entries(filesByUser)) {
                    // Sort by Date
                    groups.self.sort((a, b) => a.date - b.date);
                    groups.scene.sort((a, b) => a.date - b.date);

                    if (groups.self.length > 0) {
                        const res = await compileClips(groups.self, username, importUIContext);
                        addDownloadLink(res.blob, res.name);
                    }
                    if (groups.scene.length > 0) {
                        const res = await compileClips(groups.scene, username, importUIContext);
                        addDownloadLink(res.blob, res.name);
                    }
                }

                DOM.importStatusLog.textContent = "All compilations finished!";
                DOM.importPercentDisplay.textContent = "100%";
                DOM.importProgressBar.style.width = "100%";
                vibrate(HAPTIC.success);
            } catch (err) {
                console.error(err);
                DOM.importStatusLog.textContent = "Error: " + err.message;
                vibrate(HAPTIC.warning);
            } finally {
                APP.importState.isProcessing = false;
                DOM.importDownloadLinks.classList.remove('hidden');
                DOM.btnStartImportCompile.textContent = "Compile Again";
                DOM.btnStartImportCompile.disabled = false;
            }
        });

        function addDownloadLink(blob, filename) {
            const url = URL.createObjectURL(blob);
            const btn = document.createElement('a');
            btn.href = url;
            btn.download = filename;
            btn.className = 'flex items-center justify-between bg-slate-800 hover:bg-slate-700 border border-slate-700 text-white p-4 rounded-xl transition-all group';
            btn.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="bg-rose-600/20 text-rose-500 p-2 rounded-lg">
                        <i data-lucide="video" class="w-5 h-5"></i>
                    </div>
                    <span class="text-sm font-semibold truncate max-w-[200px]">${filename}</span>
                </div>
                <i data-lucide="download" class="w-4 h-4 text-slate-400 group-hover:text-white"></i>
            `;
            DOM.importDownloadLinks.appendChild(btn);
            DOM.importDownloadLinks.classList.remove('hidden');
            lucide.createIcons();
        }

        // Boot
        initApp();
        async function initApp() {
            try {
                // Initialize Logo
                APP.logoImg = new Image();
                APP.logoImg.src = 'assets/LogoIcon-Grey.svg';
                
                // Name Check
                if (!APP.userName) {
                    const name = prompt("Enter your name:");
                    if (name && name.trim().length > 0) {
                        APP.userName = name.trim();
                        localStorage.setItem('user_name', APP.userName);
                    }
                }
                
                await initDB();
                
                updateGreeting();
                updateMonthLabel();
                updateTargetUI();
                renderCalendar();
            } catch(e) { console.error(e); }
        }

    </script>
</body>
</html>
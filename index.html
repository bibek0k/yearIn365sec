<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1 Second A Day</title>
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FFmpeg WASM (via CDN) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>

    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --primary: #e11d48; /* Rose-600 */
            --bg: #0f172a; /* Slate-900 */
            --surface: #1e293b; /* Slate-800 */
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            overscroll-behavior-y: none;
        }

        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .camera-container {
            position: relative;
            width: 100%;
            padding-top: 177.77%; /* 9:16 Aspect Ratio */
            background: #000;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .day-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border-radius: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: all 0.2s;
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
        }

        .day-cell:hover {
            border-color: rgba(255,255,255,0.1);
        }

        .day-cell.filled {
            background: var(--primary);
            color: white;
            box-shadow: 0 0 10px rgba(225, 29, 72, 0.4);
        }
        
        .day-cell.target-active {
            border-color: #3b82f6; /* Blue border for target */
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
        }

        .safe-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Toggle Switch */
        .mode-toggle {
            background: var(--surface);
            border-radius: 9999px;
            padding: 4px;
            display: flex;
            position: relative;
        }
        .mode-btn {
            z-index: 10;
            flex: 1;
            text-align: center;
            padding: 6px 12px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 9999px;
            transition: color 0.2s;
            cursor: pointer;
        }
        .mode-bg {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc(50% - 4px);
            background: var(--primary);
            border-radius: 9999px;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center safe-pb">

    <!-- Header & Mode Switch -->
    <header class="w-full max-w-md p-6 pb-2 flex flex-col gap-4">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold tracking-tight">My Year</h1>
                <p class="text-slate-400 text-sm" id="dateDisplay">Loading...</p>
            </div>
            <!-- Mode Toggle -->
            <div class="mode-toggle w-40">
                <div id="modeBg" class="mode-bg"></div>
                <div id="modeSelf" class="mode-btn text-white">Self</div>
                <div id="modeScene" class="mode-btn text-slate-400">Scene</div>
            </div>
        </div>
        
        <!-- Search Bar -->
        <div class="flex gap-2 w-full">
            <input type="text" id="dateSearchInput" placeholder="Jump to DD-MM-YYYY" class="bg-slate-800 text-white px-4 py-2 rounded-lg flex-1 text-sm border border-slate-700 focus:outline-none focus:border-rose-600 placeholder-slate-500">
            <button id="btnSearch" class="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg transition-colors"><i data-lucide="search" class="w-4 h-4"></i></button>
        </div>

        <!-- Recording Target Indicator -->
        <div id="targetIndicator" class="hidden w-full bg-blue-500/10 border border-blue-500/20 rounded-lg p-2 text-center">
            <p class="text-blue-400 text-xs font-medium">Recording for: <span id="targetDateDisplay" class="font-bold text-blue-300"></span></p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="w-full max-w-md flex-1 px-4 flex flex-col gap-6">

        <!-- Recorder Section -->
        <div id="recorderSection" class="relative">
            <div class="camera-container">
                <video id="cameraPreview" autoplay playsinline muted class="camera-feed hidden"></video>
                <video id="playbackPreview" playsinline loop class="camera-feed hidden"></video>
                
                <!-- Start Overlay -->
                <div id="startOverlay" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/50 backdrop-blur-sm z-10 transition-opacity">
                    <button id="btnInitCamera" class="bg-rose-600 hover:bg-rose-700 text-white rounded-full p-6 shadow-lg transform transition active:scale-95">
                        <i data-lucide="camera" class="w-8 h-8"></i>
                    </button>
                    <p class="mt-4 text-sm font-medium text-white/90">Tap to Start Camera</p>
                </div>

                <!-- Done Overlay -->
                <div id="doneOverlay" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-slate-900/90 z-20">
                    <div class="bg-green-500/20 text-green-400 p-4 rounded-full mb-4">
                        <i data-lucide="check" class="w-8 h-8"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white">Captured!</h3>
                    <div class="flex gap-4 mt-6">
                         <button id="btnViewClip" class="text-sm bg-slate-700 text-white px-4 py-2 rounded-lg">View</button>
                    </div>
                </div>

                <!-- Camera Switch (Scene Mode Only) -->
                <button id="btnSwitchCam" class="hidden absolute top-4 right-4 bg-slate-800/80 text-white p-2 rounded-full z-30">
                    <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                </button>
            </div>

            <!-- Controls -->
            <div class="mt-6 flex items-center justify-center relative h-24">
                <div id="recordControls" class="relative hidden">
                    <svg class="progress-ring w-20 h-20" viewBox="0 0 100 100">
                        <circle class="text-slate-700" stroke="currentColor" stroke-width="4" fill="transparent" r="45" cx="50" cy="50"/>
                        <circle id="progressCircle" class="progress-ring__circle text-rose-500" stroke="currentColor" stroke-width="4" fill="transparent" r="45" cx="50" cy="50" stroke-dasharray="282.74" stroke-dashoffset="282.74"/>
                    </svg>
                    
                    <button id="btnRecord" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-rose-600 rounded-full border-4 border-slate-900 shadow-xl active:scale-90 transition-transform flex items-center justify-center">
                        <div id="recIcon" class="w-6 h-6 bg-white rounded-sm"></div>
                    </button>
                </div>
                <p id="statusText" class="absolute -bottom-2 text-xs text-slate-500 font-mono">Ready</p>
            </div>
        </div>

        <!-- Month Grid View -->
        <div class="bg-slate-800 rounded-xl p-4 flex flex-col gap-4">
            <!-- Month Navigation -->
            <div class="flex justify-between items-center">
                <button id="btnPrevMonth" class="p-2 hover:bg-slate-700 rounded-full text-slate-400"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                <h2 id="monthLabel" class="text-sm font-bold text-white uppercase tracking-widest">Month</h2>
                <button id="btnNextMonth" class="p-2 hover:bg-slate-700 rounded-full text-slate-400"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
            </div>

            <!-- Grid -->
            <div id="calendarGrid" class="calendar-grid">
                <!-- Days injected by JS -->
            </div>

            <!-- Tools -->
            <div class="flex gap-2 justify-center border-t border-slate-700 pt-4">
                <button id="btnCompile" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-md flex items-center gap-2 transition-colors">
                    <i data-lucide="film" class="w-3 h-3"></i> Compile Month
                </button>
                <button id="btnBackup" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-md flex items-center gap-2 transition-colors">
                    <i data-lucide="download" class="w-3 h-3"></i> Export All
                </button>
            </div>
        </div>
    </main>

    <!-- Clip Viewer / Delete Modal -->
    <div id="clipModal" class="fixed inset-0 bg-slate-950/95 z-40 hidden flex-col items-center justify-center p-6">
        <div class="relative w-full max-w-md bg-slate-900 rounded-xl overflow-hidden shadow-2xl border border-slate-800">
            <video id="modalVideo" controls class="w-full aspect-[9/16] bg-black"></video>
            <div class="p-4 flex justify-between items-center bg-slate-900">
                <button id="btnCloseClip" class="text-slate-400 hover:text-white">Close</button>
                <button id="btnDeleteClip" class="text-red-500 hover:text-red-400 font-medium flex items-center gap-2">
                    <i data-lucide="trash-2" class="w-4 h-4"></i> Delete & Replace
                </button>
            </div>
        </div>
    </div>

    <!-- Compile Modal -->
    <div id="compileModal" class="fixed inset-0 bg-slate-950/90 z-50 hidden flex-col items-center justify-center p-6 text-center">
        <div class="max-w-sm w-full bg-slate-900 border border-slate-800 p-6 rounded-2xl shadow-2xl">
            <h3 class="text-xl font-bold mb-2">Compiling Movie</h3>
            <p class="text-slate-400 text-sm mb-6">Stitching clips locally...</p>
            <div class="w-full bg-slate-800 h-2 rounded-full overflow-hidden mb-2">
                <div id="compileProgress" class="bg-rose-600 h-full w-0 transition-all duration-300"></div>
            </div>
            <p id="compileLog" class="text-xs text-slate-500 font-mono mb-6">Initializing...</p>
            <button id="btnCloseModal" class="hidden w-full bg-slate-800 text-white py-3 rounded-lg">Close</button>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- STATE & CONFIG ---
        const APP = {
            dbName: 'OneSecondADayDB',
            storeName: 'clips',
            version: 1,
            db: null,
            today: new Date().toISOString().split('T')[0],
            mediaRecorder: null,
            recordedChunks: [],
            cameraStream: null,
            ffmpeg: null,
            
            // New State for V2
            mode: 'self', // 'self' or 'scene'
            viewDate: new Date(), // Tracks month view
            targetDate: new Date().toISOString().split('T')[0], // Default recording target is today
            sceneCamFacing: 'environment' // default rear for scene
        };

        const DOM = {
            // Displays
            dateDisplay: document.getElementById('dateDisplay'),
            targetDateDisplay: document.getElementById('targetDateDisplay'),
            targetIndicator: document.getElementById('targetIndicator'),
            monthLabel: document.getElementById('monthLabel'),
            statusText: document.getElementById('statusText'),
            
            // Search
            dateSearchInput: document.getElementById('dateSearchInput'),
            btnSearch: document.getElementById('btnSearch'),

            // Camera
            cameraPreview: document.getElementById('cameraPreview'),
            playbackPreview: document.getElementById('playbackPreview'),
            
            // Mode Switcher
            modeSelf: document.getElementById('modeSelf'),
            modeScene: document.getElementById('modeScene'),
            modeBg: document.getElementById('modeBg'),
            
            // Overlays & Buttons
            startOverlay: document.getElementById('startOverlay'),
            doneOverlay: document.getElementById('doneOverlay'),
            btnInit: document.getElementById('btnInitCamera'),
            btnRecord: document.getElementById('btnRecord'),
            btnRetake: document.getElementById('btnRetake'),
            btnSwitchCam: document.getElementById('btnSwitchCam'),
            btnViewClip: document.getElementById('btnViewClip'),
            
            // Grid & Nav
            calendarGrid: document.getElementById('calendarGrid'),
            btnPrevMonth: document.getElementById('btnPrevMonth'),
            btnNextMonth: document.getElementById('btnNextMonth'),
            
            // Modals
            clipModal: document.getElementById('clipModal'),
            modalVideo: document.getElementById('modalVideo'),
            btnCloseClip: document.getElementById('btnCloseClip'),
            btnDeleteClip: document.getElementById('btnDeleteClip'),
            
            // Compile
            btnCompile: document.getElementById('btnCompile'),
            compileModal: document.getElementById('compileModal'),
            compileProgress: document.getElementById('compileProgress'),
            compileLog: document.getElementById('compileLog'),
            btnCloseModal: document.getElementById('btnCloseModal'),
            
            // Icons & Rings
            recordControls: document.getElementById('recordControls'),
            progressCircle: document.getElementById('progressCircle'),
            recIcon: document.getElementById('recIcon'),
            btnBackup: document.getElementById('btnBackup')
        };

        // --- INIT ---
        DOM.dateDisplay.textContent = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

        // Helper to format dates as DD-MM-YYYY for display
        function formatDateDisplay(isoDateString) {
            if (!isoDateString) return '';
            const [y, m, d] = isoDateString.split('-');
            return `${d}-${m}-${y}`;
        }
        
        // --- DATABASE ---
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(APP.dbName, APP.version);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(APP.storeName)) {
                        db.createObjectStore(APP.storeName, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => { APP.db = e.target.result; resolve(APP.db); };
                request.onerror = (e) => reject(e);
            });
        }

        // Key Format: "mode_YYYY-MM-DD" e.g., "self_2024-03-21"
        function getKey(date, mode) {
            return `${mode}_${date}`;
        }

        async function saveClip(date, mode, blob) {
            const id = getKey(date, mode);
            return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.put({ id: id, date: date, mode: mode, blob: blob, timestamp: Date.now() });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getClip(date, mode) {
            if (!APP.db) return null;
            const id = getKey(date, mode);
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        }
        
        async function deleteClip(date, mode) {
            const id = getKey(date, mode);
             return new Promise((resolve, reject) => {
                const tx = APP.db.transaction(APP.storeName, 'readwrite');
                const store = tx.objectStore(APP.storeName);
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getAllClips(mode) {
             if (!APP.db) return [];
            return new Promise((resolve) => {
                const tx = APP.db.transaction(APP.storeName, 'readonly');
                const req = tx.objectStore(APP.storeName).getAll();
                req.onsuccess = () => {
                    const all = req.result || [];
                    resolve(all.filter(c => c.mode === mode));
                };
            });
        }

        // --- SEARCH LOGIC ---
        DOM.btnSearch.addEventListener('click', handleSearch);
        DOM.dateSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });

        async function handleSearch() {
            const input = DOM.dateSearchInput.value.trim();
            // Regex validation for DD-MM-YYYY
            const regex = /^(\d{2})-(\d{2})-(\d{4})$/;
            const match = input.match(regex);
            
            if (!match) { 
                alert("Please enter date in DD-MM-YYYY format"); 
                return; 
            }
            
            const [_, d, m, y] = match;
            const isoDate = `${y}-${m}-${d}`;
            
            // Basic date validation
            const testDate = new Date(isoDate);
            if (isNaN(testDate.getTime())) {
                alert("Invalid date");
                return;
            }

            // Update View to that month
            APP.viewDate = new Date(Number(y), Number(m) - 1, 1);
            updateMonthLabel();
            
            const clip = await getClip(isoDate, APP.mode);
            
            if (clip) {
                // Video exists -> render calendar to show it and open modal
                await renderCalendar();
                openClipModal(isoDate);
            } else {
                // No video -> select as target
                setTargetDate(isoDate);
                // Alert the user briefly or update status text
                DOM.statusText.textContent = `Jumped to ${input}`;
            }
        }

        // --- VIEW & NAVIGATION LOGIC ---

        function updateMonthLabel() {
            DOM.monthLabel.textContent = APP.viewDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        async function renderCalendar() {
            const clips = await getAllClips(APP.mode);
            const clipMap = new Set(clips.map(c => c.date));
            
            DOM.calendarGrid.innerHTML = '';
            
            const year = APP.viewDate.getFullYear();
            const month = APP.viewDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                const dateObj = new Date(year, month, d);
                const dayOfYear = getDayOfYear(dateObj);
                
                const el = document.createElement('div');
                el.className = 'day-cell';
                el.title = formatDateDisplay(dateStr); // Tooltip in DD-MM-YYYY
                
                const hasClip = clipMap.has(dateStr);
                const isTarget = dateStr === APP.targetDate;

                el.innerHTML = `<span class="text-xs font-bold">Day</span><span class="text-lg leading-none">${dayOfYear}</span>`;

                if (hasClip) {
                    el.classList.add('filled');
                    el.onclick = () => openClipModal(dateStr);
                } else {
                    el.onclick = () => setTargetDate(dateStr);
                }

                if (isTarget) {
                    el.classList.add('target-active');
                }

                DOM.calendarGrid.appendChild(el);
            }
        }

        DOM.btnPrevMonth.addEventListener('click', () => {
            APP.viewDate.setMonth(APP.viewDate.getMonth() - 1);
            updateMonthLabel();
            renderCalendar();
        });

        DOM.btnNextMonth.addEventListener('click', () => {
            APP.viewDate.setMonth(APP.viewDate.getMonth() + 1);
            updateMonthLabel();
            renderCalendar();
        });

        // --- MODE SWITCHING ---

        function setMode(mode) {
            APP.mode = mode;
            APP.targetDate = APP.today;
            updateTargetUI();
            
            if (mode === 'self') {
                DOM.modeSelf.classList.replace('text-slate-400', 'text-white');
                DOM.modeScene.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(0)';
                DOM.btnSwitchCam.classList.add('hidden');
            } else {
                DOM.modeScene.classList.replace('text-slate-400', 'text-white');
                DOM.modeSelf.classList.replace('text-white', 'text-slate-400');
                DOM.modeBg.style.transform = 'translateX(100%)';
                if(APP.cameraStream) DOM.btnSwitchCam.classList.remove('hidden');
            }
            
            renderCalendar();
            resetRecorderUI();
            if (APP.cameraStream) startCamera(); 
        }

        DOM.modeSelf.addEventListener('click', () => setMode('self'));
        DOM.modeScene.addEventListener('click', () => setMode('scene'));

        // --- REPLACE / TARGET LOGIC ---

        function setTargetDate(date) {
            APP.targetDate = date;
            updateTargetUI();
            resetRecorderUI();
            renderCalendar();
        }
        
        function updateTargetUI() {
            DOM.targetDateDisplay.textContent = formatDateDisplay(APP.targetDate); // Display DD-MM-YYYY
            if (APP.targetDate !== APP.today) {
                DOM.targetIndicator.classList.remove('hidden');
                DOM.statusText.textContent = `Ready for ${formatDateDisplay(APP.targetDate)}`; // Display DD-MM-YYYY
            } else {
                DOM.targetIndicator.classList.add('hidden');
                DOM.statusText.textContent = "Ready";
            }
            checkTargetStatus();
        }
        
        async function checkTargetStatus() {
            const existing = await getClip(APP.targetDate, APP.mode);
            if (existing) {
                showDoneState(existing.blob);
            } else {
                showReadyState();
            }
        }

        async function openClipModal(date) {
            const clip = await getClip(date, APP.mode);
            if (!clip) return;
            
            DOM.modalVideo.src = URL.createObjectURL(clip.blob);
            DOM.clipModal.classList.remove('hidden');
            DOM.clipModal.classList.add('flex');
            
            DOM.btnDeleteClip.onclick = async () => {
                // Confirm using DD-MM-YYYY
                if (confirm(`Delete video for ${formatDateDisplay(date)}?`)) {
                    await deleteClip(date, APP.mode);
                    DOM.clipModal.classList.add('hidden');
                    DOM.clipModal.classList.remove('flex');
                    setTargetDate(date);
                }
            };
        }
        
        DOM.btnCloseClip.addEventListener('click', () => {
            DOM.clipModal.classList.add('hidden');
            DOM.clipModal.classList.remove('flex');
            DOM.modalVideo.pause();
        });

        // --- CAMERA & RECORDING ---
        
        DOM.btnInit.addEventListener('click', startCamera);
        DOM.btnSwitchCam.addEventListener('click', () => {
            APP.sceneCamFacing = APP.sceneCamFacing === 'environment' ? 'user' : 'environment';
            startCamera();
        });

        async function startCamera() {
             if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                alert("Camera requires HTTPS."); return;
            }

            if (APP.cameraStream) {
                APP.cameraStream.getTracks().forEach(t => t.stop());
            }

            DOM.statusText.textContent = "Starting camera...";
            
            // HIGH QUALITY CONSTRAINTS - Enforce 9:16 Portrait @ 1080p
            let constraints = { 
                audio: true, 
                video: {
                    width: { ideal: 1080 }, // Portrait Width
                    height: { ideal: 1920 }, // Portrait Height
                    aspectRatio: { ideal: 0.5625 } // 9:16 Aspect Ratio
                } 
            };
            
            // Handle Facing Mode
            if (APP.mode === 'self') {
                constraints.video.facingMode = 'user';
            } else {
                constraints.video.facingMode = { ideal: APP.sceneCamFacing };
            }

            try {
                APP.cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                DOM.cameraPreview.srcObject = APP.cameraStream;
                DOM.cameraPreview.classList.remove('hidden');
                DOM.playbackPreview.classList.add('hidden');
                DOM.startOverlay.classList.add('opacity-0', 'pointer-events-none');
                DOM.recordControls.classList.remove('hidden');
                DOM.statusText.textContent = `Ready (${APP.mode})`;
                
                if (APP.mode === 'scene') DOM.btnSwitchCam.classList.remove('hidden');
                
            } catch (err) {
                console.error(err);
                alert("Camera Error: " + err.name);
                DOM.statusText.textContent = "Camera Error";
            }
        }

        DOM.btnRecord.addEventListener('click', startRecording);

        function startRecording() {
            if (!APP.cameraStream) return;
            
            DOM.btnRecord.disabled = true;
            DOM.recIcon.classList.replace('rounded-sm', 'rounded-full');
            DOM.recIcon.classList.add('animate-pulse');
            DOM.statusText.textContent = "Recording...";
            APP.recordedChunks = [];

            const mimeOptions = ["video/webm;codecs=vp8", "video/webm;codecs=vp9", "video/webm", "video/mp4"];
            const selectedMime = mimeOptions.find(type => MediaRecorder.isTypeSupported(type));

            if (!selectedMime) {
                alert("Browser not supported.");
                return;
            }

            try {
                // High Bitrate for Quality
                APP.mediaRecorder = new MediaRecorder(APP.cameraStream, { 
                    mimeType: selectedMime,
                    videoBitsPerSecond: 8000000 // 8 Mbps
                });
            } catch (e) {
                alert("Recorder Error: " + e.message); return;
            }

            APP.mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) APP.recordedChunks.push(e.data); };
            APP.mediaRecorder.onstop = async () => {
                const blob = new Blob(APP.recordedChunks, { type: selectedMime.split(';')[0] });
                await handleRecordingComplete(blob);
            };

            APP.mediaRecorder.start();

            const circumference = 45 * 2 * Math.PI;
            DOM.progressCircle.style.strokeDashoffset = circumference;
            requestAnimationFrame(() => {
                DOM.progressCircle.style.transition = 'stroke-dashoffset 1s linear';
                DOM.progressCircle.style.strokeDashoffset = '0';
            });

            setTimeout(() => {
                if (APP.mediaRecorder.state === 'recording') APP.mediaRecorder.stop();
            }, 1000);
        }

        async function handleRecordingComplete(blob) {
            await saveClip(APP.targetDate, APP.mode, blob);
            downloadFile(blob, `${APP.mode}_${formatDateDisplay(APP.targetDate)}.webm`);
            await renderCalendar();
            showDoneState(blob);
        }

        function showDoneState(blob) {
            DOM.playbackPreview.src = URL.createObjectURL(blob);
            DOM.playbackPreview.classList.remove('hidden');
            DOM.cameraPreview.classList.add('hidden');
            DOM.doneOverlay.classList.remove('hidden');
            DOM.recordControls.classList.add('hidden');
            DOM.statusText.textContent = "Saved.";
            
            DOM.btnViewClip.onclick = () => {
                DOM.modalVideo.src = URL.createObjectURL(blob);
                DOM.clipModal.classList.remove('hidden');
                DOM.clipModal.classList.add('flex');
            };
        }
        
        function resetRecorderUI() {
             DOM.doneOverlay.classList.add('hidden');
             DOM.playbackPreview.classList.add('hidden');
             DOM.cameraPreview.classList.remove('hidden');
             
             if (APP.cameraStream) {
                 DOM.recordControls.classList.remove('hidden');
                 DOM.startOverlay.classList.add('opacity-0', 'pointer-events-none');
             } else {
                 DOM.recordControls.classList.add('hidden');
                 DOM.startOverlay.classList.remove('opacity-0', 'pointer-events-none');
             }
             
             showReadyState();
        }

        function showReadyState() {
            DOM.doneOverlay.classList.add('hidden');
            DOM.playbackPreview.classList.add('hidden');
            DOM.cameraPreview.classList.remove('hidden');
            
            DOM.progressCircle.style.transition = 'none';
            DOM.progressCircle.style.strokeDashoffset = 45 * 2 * Math.PI;
            DOM.btnRecord.disabled = false;
            DOM.recIcon.classList.replace('rounded-full', 'rounded-sm');
            DOM.recIcon.classList.remove('animate-pulse');
        }

        // --- COMPILATION ---
        
        DOM.btnCompile.addEventListener('click', async () => {
            const clips = await getAllClips(APP.mode);
            const year = APP.viewDate.getFullYear();
            const month = String(APP.viewDate.getMonth() + 1).padStart(2, '0');
            const monthPrefix = `${year}-${month}`;
            const monthClips = clips.filter(c => c.date.startsWith(monthPrefix));
            
            if (monthClips.length < 2) { alert("Need at least 2 clips in this month to compile."); return; }
            
            DOM.compileModal.classList.remove('hidden');
            DOM.compileModal.classList.add('flex');
            
            try { await runFFmpeg(monthClips); }
            catch (err) { DOM.compileLog.innerHTML = `<span class="text-red-400">Error: ${err.message}<br>Check secure context.</span>`; DOM.btnCloseModal.classList.remove('hidden'); }
        });

        DOM.btnCloseModal.addEventListener('click', () => {
            DOM.compileModal.classList.add('hidden'); DOM.compileModal.classList.remove('flex');
        });

        async function runFFmpeg(clips) {
            const { FFmpeg } = FFmpegWASM;
            const { fetchFile } = FFmpegUtil;
            if (!APP.ffmpeg) {
                APP.ffmpeg = new FFmpeg();
                await APP.ffmpeg.load({ 
                    coreURL: 'https://unpkg.com/@ffmpeg/core@0.12.7/dist/ffmpeg-core.js',
                    wasmURL: 'https://unpkg.com/@ffmpeg/core@0.12.7/dist/ffmpeg-core.wasm'
                });
            }
            
            clips.sort((a, b) => a.date.localeCompare(b.date));
            let fileList = '';
            for (let i = 0; i < clips.length; i++) {
                await APP.ffmpeg.writeFile(`c${i}.webm`, await fetchFile(clips[i].blob));
                fileList += `file 'c${i}.webm'\n`;
            }
            await APP.ffmpeg.writeFile('f.txt', fileList);
            
            DOM.compileLog.textContent = "Stitching...";
            try { await APP.ffmpeg.exec(['-f', 'concat', '-safe', '0', '-i', 'f.txt', '-c', 'copy', 'out.webm']); }
            catch { await APP.ffmpeg.exec(['-f', 'concat', '-safe', '0', '-i', 'f.txt', 'out.webm']); }
            
            const data = await APP.ffmpeg.readFile('out.webm');
            downloadFile(new Blob([data.buffer], { type: 'video/webm' }), `Movie_${APP.mode}_${APP.viewDate.toISOString().slice(0,7)}.webm`);
            DOM.compileLog.textContent = "Done.";
            DOM.btnCloseModal.classList.remove('hidden');
        }

        // --- UTILS ---
        function downloadFile(blob, name) {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }

        DOM.btnBackup.addEventListener('click', () => alert("Daily clips are saved to your Downloads folder automatically when recorded."));

        // Boot
        initApp();
        async function initApp() {
            try {
                await initDB();
                updateMonthLabel();
                updateTargetUI();
                renderCalendar();
            } catch(e) { console.error(e); }
        }

    </script>
</body>
</html>